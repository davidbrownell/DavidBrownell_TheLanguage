# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------
"""\
Basic building blocks for token processing.
"""


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String

    from .Normalize_TheLanguage import GetNumMultilineTokenDelimiters, LineInfo, multiline_token_delimiter_length
    from .NormalizedIterator_TheLanguage import NormalizedIterator

# Visibility: private
# ClassModifier: immutable
# ClassType: Class
class Token(object):
    def __init__(self, *args, **kwargs):
        Token._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # name, is_always_ignored, is_control_token

        # No bases

        # name
        if "name" in kwargs:
            self.name = kwargs.pop("name")
        elif args:
            self.name = args.pop(0)
        else:
            raise Exception("name was not provided")

        # is_always_ignored
        if "is_always_ignored" in kwargs:
            self.is_always_ignored = kwargs.pop("is_always_ignored")
        elif args:
            self.is_always_ignored = args.pop(0)
        else:
            raise Exception("is_always_ignored was not provided")

        # is_control_token
        if "is_control_token" in kwargs:
            self.is_control_token = kwargs.pop("is_control_token")
        elif args:
            self.is_control_token = args.pop(0)
        else:
            raise Exception("is_control_token was not provided")

        self._Init_34f2389de2a94953901a5381054b43d4_()

    def __eq__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        # No bases

        result = cls.__CompareItem__(a.name, b.name)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_always_ignored, b.is_always_ignored)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_control_token, b.is_control_token)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_34f2389de2a94953901a5381054b43d4_(self):
        pass

    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(object):
        def __init__(self, *args, **kwargs):
            Token.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # iterator

            # No bases

            # iterator
            if "iterator" in kwargs:
                self.iterator = kwargs.pop("iterator")
            elif args:
                self.iterator = args.pop(0)
            else:
                raise Exception("iterator was not provided")

            self._Init_94c30e466aa84b86891195f29ba38ba2_()

        def __eq__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            # No bases

            result = cls.__CompareItem__(a.iterator, b.iterator)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b):
            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        def _Init_94c30e466aa84b86891195f29ba38ba2_(self):
            pass

    @property
    def Name(self): return self.name
    @property
    def IsAlwaysIgnored(self): return self.is_always_ignored
    @property
    def IsControlToken(self): return self.is_control_token
    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        raise Exception("Abstract/Deferred method")

Token_MatchResult = Token.MatchResult
# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class NewlineToken(Token):
    """\
    Token that matches 1 or more newlines.
    """

    def __init__(self, *args, **kwargs):
        NewlineToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # capture_many

        Token._InternalInit(self, args, kwargs)

        # capture_many
        if "capture_many" in kwargs:
            self.capture_many = kwargs.pop("capture_many")
        elif args:
            self.capture_many = args.pop(0)
        else:
            raise Exception("capture_many was not provided")

        self._Init_97c13d944d3049e5a05c9c2344e2ed34_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = Token.__Compare__(a, b)
        if result != 0: return result

        result = cls.__CompareItem__(a.capture_many, b.capture_many)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_97c13d944d3049e5a05c9c2344e2ed34_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            NewlineToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end

            NewlineToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            self._Init_2b1e5903ff9244bfada31217285a8f8f_()

        def __eq__(self, other):
            if NewlineToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if NewlineToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if NewlineToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if NewlineToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if NewlineToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if NewlineToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            result = NewlineToken.Token_MatchResult.__Compare__(a, b)
            if result != 0: return result

            result = cls.__CompareItem__(a.start, b.start)
            if result is not None: return result

            result = cls.__CompareItem__(a.end, b.end)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b):
            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        # Return Type: None
        def _Init_2b1e5903ff9244bfada31217285a8f8f_(self):
            assert self.start <= self.end

    # Return Type: NewlineToken val
    @staticmethod
    def Create(capture_many=True, is_always_ignored=False, ):
        return NewlineToken(name="Newline+" if capture_many else "Newline", is_control_token=False, is_always_ignored=is_always_ignored, capture_many=capture_many, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.EndOfLine:
            return None

        newline_start = iterator.OffsetProper()
        iterator.Advance(1, )
        if self.capture_many:
            while iterator.IsBlankLine():
                iterator.SkipLine()

        return NewlineToken.MatchResult(iterator, newline_start, iterator.OffsetProper(), )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class IndentToken(Token):
    """\
    Token matching indentations of arbitrary length.
    """

    def __init__(self, *args, **kwargs):
        IndentToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_5f9136dfbe1145d0a43126e9063c6adf_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = Token.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_5f9136dfbe1145d0a43126e9063c6adf_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            IndentToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end, indent_value

            IndentToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            # indent_value
            if "indent_value" in kwargs:
                self.indent_value = kwargs.pop("indent_value")
            elif args:
                self.indent_value = args.pop(0)
            else:
                raise Exception("indent_value was not provided")

            self._Init_a03dce20a977405783309ad2b56d9618_()

        def __eq__(self, other):
            if IndentToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if IndentToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if IndentToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if IndentToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if IndentToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if IndentToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            result = IndentToken.Token_MatchResult.__Compare__(a, b)
            if result != 0: return result

            result = cls.__CompareItem__(a.start, b.start)
            if result is not None: return result

            result = cls.__CompareItem__(a.end, b.end)
            if result is not None: return result

            result = cls.__CompareItem__(a.indent_value, b.indent_value)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b):
            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        # Return Type: None
        def _Init_a03dce20a977405783309ad2b56d9618_(self):
            assert self.start <= self.end

    # Return Type: IndentToken val
    @staticmethod
    def Create():
        return IndentToken(name="Indent", is_control_token=False, is_always_ignored=False, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Indent:
            return None

        iterator.SkipWhitespacePrefix()
        line_info = iterator.LineInfoProper()
        assert line_info.new_indentation_value is not None
        return IndentToken.MatchResult(iterator, line_info.offset_start, line_info.content_start, line_info.new_indentation_value, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class DedentToken(Token):
    """\
    Token matching a single dedentation.
    """

    def __init__(self, *args, **kwargs):
        DedentToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_b078b0bf7c9d4da1a96b1d6ff03c0bc9_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = Token.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_b078b0bf7c9d4da1a96b1d6ff03c0bc9_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            DedentToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # 

            DedentToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # No members

            self._Init_3da3d11fa3e34413a6029d01bf88ab55_()

        def __eq__(self, other):
            if DedentToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if DedentToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if DedentToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if DedentToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if DedentToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if DedentToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            result = DedentToken.Token_MatchResult.__Compare__(a, b)
            if result != 0: return result



            return 0

        @classmethod
        def __CompareItem__(cls, a, b):
            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        def _Init_3da3d11fa3e34413a6029d01bf88ab55_(self):
            pass

        pass
    # Return Type: DedentToken val
    @staticmethod
    def Create():
        return DedentToken(name="Dedent", is_control_token=False, is_always_ignored=False, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Dedent:
            return None

        iterator.ConsumeDedent()
        if iterator.GetNextTokenType() == NormalizedIterator.TokenType.WhitespacePrefix:
            iterator.SkipWhitespacePrefix()

        return DedentToken.MatchResult(iterator, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class HorizontalWhitespaceToken(Token):
    """\
    Token that matches horizontal whitespace.
    """

    def __init__(self, *args, **kwargs):
        HorizontalWhitespaceToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_ca9d9c96292847698bde49c5a5e0a9df_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = Token.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_ca9d9c96292847698bde49c5a5e0a9df_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            HorizontalWhitespaceToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end

            HorizontalWhitespaceToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            self._Init_b3c5c2c8d0cd4a4dbd4634454825ed14_()

        def __eq__(self, other):
            if HorizontalWhitespaceToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if HorizontalWhitespaceToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if HorizontalWhitespaceToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if HorizontalWhitespaceToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if HorizontalWhitespaceToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if HorizontalWhitespaceToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            result = HorizontalWhitespaceToken.Token_MatchResult.__Compare__(a, b)
            if result != 0: return result

            result = cls.__CompareItem__(a.start, b.start)
            if result is not None: return result

            result = cls.__CompareItem__(a.end, b.end)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b):
            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        def _Init_b3c5c2c8d0cd4a4dbd4634454825ed14_(self):
            pass

    # Return Type: HorizontalWhitespaceToken val
    @staticmethod
    def Create():
        return HorizontalWhitespaceToken(name="HorizontalWhitespace", is_control_token=False, is_always_ignored=True, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Content:
            return None

        whitespace_range = iterator.GetNextWhitespaceRange()
        if whitespace_range is None or iterator.OffsetProper() != whitespace_range.begin:
            return None

        iterator.Advance(whitespace_range.end - whitespace_range.begin, )
        return HorizontalWhitespaceToken.MatchResult(iterator, whitespace_range.begin, whitespace_range.end, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class RegexToken(Token):
    """\
    Token that matches content against a regular expression.
    """

    def __init__(self, *args, **kwargs):
        RegexToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # regex, is_multiline

        Token._InternalInit(self, args, kwargs)

        # regex
        if "regex" in kwargs:
            self.regex = kwargs.pop("regex")
        elif args:
            self.regex = args.pop(0)
        else:
            raise Exception("regex was not provided")

        # is_multiline
        if "is_multiline" in kwargs:
            self.is_multiline = kwargs.pop("is_multiline")
        elif args:
            self.is_multiline = args.pop(0)
        else:
            raise Exception("is_multiline was not provided")

        self._Init_853156e482bc48289057340b21ea5c97_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = Token.__Compare__(a, b)
        if result != 0: return result

        result = cls.__CompareItem__(a.regex, b.regex)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_multiline, b.is_multiline)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_853156e482bc48289057340b21ea5c97_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            RegexToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # match

            RegexToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # match
            if "match" in kwargs:
                self.match = kwargs.pop("match")
            elif args:
                self.match = args.pop(0)
            else:
                raise Exception("match was not provided")

            self._Init_f631d837b95643c9b2195f2bd4d0a811_()

        def __eq__(self, other):
            if RegexToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if RegexToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if RegexToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if RegexToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if RegexToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if RegexToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            result = RegexToken.Token_MatchResult.__Compare__(a, b)
            if result != 0: return result

            result = cls.__CompareItem__(a.match, b.match)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b):
            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        def _Init_f631d837b95643c9b2195f2bd4d0a811_(self):
            pass

    # Return Type: RegexToken
    @staticmethod
    def Create(name, regex, is_multiline=False, is_always_ignored=False, ):
        if is_multiline:
            pattern = regex.pattern.replace("\\", "")
            pattern_len = len(pattern)
            assert GetNumMultilineTokenDelimiters(pattern, start_index=0, end_index=Min(pattern_len, multiline_token_delimiter_length, ), ) == 1, (pattern, "The opening token must be a multiline phrase token", )
            assert GetNumMultilineTokenDelimiters(pattern, start_index=Max(0, pattern_len - multiline_token_delimiter_length, ), end_index=pattern_len, ) == 1, (pattern, "The closing token must be a multiline phrase token", )

        return RegexToken(name=name, is_control_token=False, is_always_ignored=is_always_ignored, regex=regex, is_multiline=is_multiline, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Content:
            return None

        match = self.regex.match(
            iterator.ContentProper(),
            pos=iterator.OffsetProper(),
            endpos=iterator.ContentLengthProper() if self.is_multiline else iterator.LineInfoProper().content_end,
        )
        if match is None:
            return None
        match_length = match.end() - match.start()
        if self.is_multiline:
            iterator = RegexToken._AdvanceMultiline(iterator, match_length, )
        else:
            iterator.Advance(match_length, )

        return RegexToken.MatchResult(iterator, match, )

    # Return Type: NormalizedIterator var
    @staticmethod
    def _AdvanceMultiline(iterator, delta, ):
        while delta:
            while iterator.GetNextTokenType() == NormalizedIterator.TokenType.Dedent:
                iterator.ConsumeDedent()
            this_delta = Min(delta, iterator.LineInfoProper().offset_end - iterator.OffsetProper(), )
            if this_delta != 0:
                iterator.Advance(this_delta, )
                delta -= this_delta

            if delta:
                iterator.Advance(1, )
                delta -= 1

        return iterator

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class ControlTokenBase(Token):
    def __init__(self, *args, **kwargs):
        ControlTokenBase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # closing_token, opening_token

        kwargs["is_control_token"] = True
        kwargs["is_always_ignored"] = False

        Token._InternalInit(self, args, kwargs)

        # closing_token
        if "closing_token" in kwargs:
            self.closing_token = kwargs.pop("closing_token")
        elif args:
            self.closing_token = args.pop(0)
        else:
            raise Exception("closing_token was not provided")

        # opening_token
        if "opening_token" in kwargs:
            self.opening_token = kwargs.pop("opening_token")
        elif args:
            self.opening_token = args.pop(0)
        else:
            raise Exception("opening_token was not provided")

        self._Init_781be172767d44f08e7f3e9c0679199e_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = Token.__Compare__(a, b)
        if result != 0: return result

        result = cls.__CompareItem__(a.is_control_token, b.is_control_token)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_always_ignored, b.is_always_ignored)
        if result is not None: return result

        result = cls.__CompareItem__(a.closing_token, b.closing_token)
        if result is not None: return result

        result = cls.__CompareItem__(a.opening_token, b.opening_token)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        raise Exception("This method should never be invoked for control tokens", )

    # Return Type: None
    def _Init_781be172767d44f08e7f3e9c0679199e_(self):
        assert ((self.closing_token is not None and self.opening_token is None) or (self.closing_token is None and self.opening_token is not None))

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PushIgnoreWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PushIgnoreWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_b3c4aeddcb634a2fb65fed73f5b0fbeb_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = ControlTokenBase.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_b3c4aeddcb634a2fb65fed73f5b0fbeb_(self):
        pass

    # Return Type: PushIgnoreWhitespaceControlToken
    @staticmethod
    def Create():
        return PushIgnoreWhitespaceControlToken(name="PushIgnoreWhitespaceControl", opening_token=None, closing_token=PopIgnoreWhitespaceControlToken, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PopIgnoreWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PopIgnoreWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_c084a16830a0444daa45b4db9125fd11_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = ControlTokenBase.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_c084a16830a0444daa45b4db9125fd11_(self):
        pass

    # Return Type: PopIgnoreWhitespaceControlToken
    @staticmethod
    def Create():
        return PopIgnoreWhitespaceControlToken(name="PopIgnoreWhitespaceControl", opening_token=PushIgnoreWhitespaceControlToken, closing_token=None, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PushPreserveWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PushPreserveWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_352e165a474d4e8aaf6e9f0a56bd1f7f_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = ControlTokenBase.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_352e165a474d4e8aaf6e9f0a56bd1f7f_(self):
        pass

    # Return Type: PushPreserveWhitespaceControlToken
    @staticmethod
    def Create():
        return PushPreserveWhitespaceControlToken(name="PushPreserveWhitespaceControl", opening_token=None, closing_token=PopPreserveWhitespaceControlToken, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PopPreserveWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PopPreserveWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_9a838d21a7cd4b81a7c9f7e60fee166b_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        result = ControlTokenBase.__Compare__(a, b)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b):
        if a is None and b is None:
            return None

        if a is None: return -1
        if b is None: return 1

        try:
            if a < b: return -1
            if a > b: return 1
        except TypeError:
            a = id(a)
            b = id(b)

            if a < b: return -1
            if a > b: return 1

        return None

    def _Init_9a838d21a7cd4b81a7c9f7e60fee166b_(self):
        pass

    # Return Type: PopPreserveWhitespaceControlToken
    @staticmethod
    def Create():
        return PopPreserveWhitespaceControlToken(name="PopPreserveWhitespaceControl", opening_token=PushPreserveWhitespaceControlToken, closing_token=None, )

