0) 0, 3
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[1, 4] (3)"
    type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(0, 3), match='one'>"
1) 3, 4
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 4] (3)"
      end: "[2, 1] (4)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 3
        end: 4
2) 0, 4
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[1, 4] (3)"
        type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
          match: "<_sre.SRE_Match object; span=(0, 3), match='one'>"
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 4] (3)"
          end: "[2, 1] (4)"
        type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
          range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
            begin: 3
            end: 4
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[2, 1] (4)"
    type: "Lower <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
3) 0, 4
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 1] (0)"
              end: "[1, 4] (3)"
            type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(0, 3), match='one'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 4] (3)"
              end: "[2, 1] (4)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 3
                end: 4
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[2, 1] (4)"
        type: "Lower <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[2, 1] (4)"
    type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
4) 0, 4
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[1, 1] (0)"
                  end: "[1, 4] (3)"
                type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(0, 3), match='one'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[1, 4] (3)"
                  end: "[2, 1] (4)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 3
                    end: 4
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 1] (0)"
              end: "[2, 1] (4)"
            type: "Lower <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[2, 1] (4)"
        type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[2, 1] (4)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
5) 4, 7
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (4)"
      end: "[2, 4] (7)"
    type: "Upper Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(4, 7), match='TWO'>"
6) 7, 8
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 4] (7)"
      end: "[3, 1] (8)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 7
        end: 8
7) 4, 8
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 1] (4)"
          end: "[2, 4] (7)"
        type: "Upper Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
          match: "<_sre.SRE_Match object; span=(4, 7), match='TWO'>"
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 4] (7)"
          end: "[3, 1] (8)"
        type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
          range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
            begin: 7
            end: 8
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (4)"
      end: "[3, 1] (8)"
    type: "Upper <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
8) 4, 7
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (4)"
      end: "[2, 4] (7)"
    type: "Upper Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(4, 7), match='TWO'>"
9) 4, 8
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[2, 1] (4)"
              end: "[2, 4] (7)"
            type: "Upper Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(4, 7), match='TWO'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[2, 4] (7)"
              end: "[3, 1] (8)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 7
                end: 8
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 1] (4)"
          end: "[3, 1] (8)"
        type: "Upper <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (4)"
      end: "[3, 1] (8)"
    type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
10) 4, 8
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[2, 1] (4)"
                  end: "[2, 4] (7)"
                type: "Upper Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(4, 7), match='TWO'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[2, 4] (7)"
                  end: "[3, 1] (8)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 7
                    end: 8
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[2, 1] (4)"
              end: "[3, 1] (8)"
            type: "Upper <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 1] (4)"
          end: "[3, 1] (8)"
        type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (4)"
      end: "[3, 1] (8)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
11) 8, 15
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (8)"
      end: "[3, 8] (15)"
    type: "Include Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(8, 15), match='include'>"
12) 16, 22
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 9] (16)"
      end: "[3, 15] (22)"
    type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(16, 22), match='number'>"
13) 22, 23
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 15] (22)"
      end: "[4, 1] (23)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 22
        end: 23
14) 0, 1
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[1, 2] (1)"
    type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(0, 1), match='4'>"
15) 1, 2
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 2] (1)"
      end: "[2, 1] (2)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 1
        end: 2
16) 0, 2
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[1, 2] (1)"
        type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
          match: "<_sre.SRE_Match object; span=(0, 1), match='4'>"
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 2] (1)"
          end: "[2, 1] (2)"
        type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
          range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
            begin: 1
            end: 2
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[2, 1] (2)"
    type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
17) 0, 2
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 1] (0)"
              end: "[1, 2] (1)"
            type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(0, 1), match='4'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 2] (1)"
              end: "[2, 1] (2)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 1
                end: 2
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[2, 1] (2)"
        type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[2, 1] (2)"
    type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
18) 0, 2
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[1, 1] (0)"
                  end: "[1, 2] (1)"
                type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(0, 1), match='4'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[1, 2] (1)"
                  end: "[2, 1] (2)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 1
                    end: 2
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 1] (0)"
              end: "[2, 1] (2)"
            type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[2, 1] (2)"
        type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[2, 1] (2)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
19) 2, 3
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (2)"
      end: "[2, 2] (3)"
    type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(2, 3), match='5'>"
20) 3, 4
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 2] (3)"
      end: "[3, 1] (4)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 3
        end: 4
21) 2, 4
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 1] (2)"
          end: "[2, 2] (3)"
        type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
          match: "<_sre.SRE_Match object; span=(2, 3), match='5'>"
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 2] (3)"
          end: "[3, 1] (4)"
        type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
          range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
            begin: 3
            end: 4
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (2)"
      end: "[3, 1] (4)"
    type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
22) 2, 4
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[2, 1] (2)"
              end: "[2, 2] (3)"
            type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(2, 3), match='5'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[2, 2] (3)"
              end: "[3, 1] (4)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 3
                end: 4
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 1] (2)"
          end: "[3, 1] (4)"
        type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (2)"
      end: "[3, 1] (4)"
    type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
23) 2, 4
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[2, 1] (2)"
                  end: "[2, 2] (3)"
                type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(2, 3), match='5'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[2, 2] (3)"
                  end: "[3, 1] (4)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 3
                    end: 4
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[2, 1] (2)"
              end: "[3, 1] (4)"
            type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[2, 1] (2)"
          end: "[3, 1] (4)"
        type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[2, 1] (2)"
      end: "[3, 1] (4)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
24) 4, 5
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (4)"
      end: "[3, 2] (5)"
    type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(4, 5), match='6'>"
25) 5, 6
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 2] (5)"
      end: "[4, 1] (6)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 5
        end: 6
26) 4, 6
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[3, 1] (4)"
          end: "[3, 2] (5)"
        type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
          match: "<_sre.SRE_Match object; span=(4, 5), match='6'>"
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[3, 2] (5)"
          end: "[4, 1] (6)"
        type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
          range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
            begin: 5
            end: 6
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (4)"
      end: "[4, 1] (6)"
    type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
27) 4, 6
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 1] (4)"
              end: "[3, 2] (5)"
            type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(4, 5), match='6'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 2] (5)"
              end: "[4, 1] (6)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 5
                end: 6
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[3, 1] (4)"
          end: "[4, 1] (6)"
        type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (4)"
      end: "[4, 1] (6)"
    type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
28) 4, 6
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 1] (4)"
                  end: "[3, 2] (5)"
                type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(4, 5), match='6'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 2] (5)"
                  end: "[4, 1] (6)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 5
                    end: 6
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 1] (4)"
              end: "[4, 1] (6)"
            type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[3, 1] (4)"
          end: "[4, 1] (6)"
        type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (4)"
      end: "[4, 1] (6)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
29) 8, 15
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (8)"
      end: "[3, 8] (15)"
    type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(8, 15), match='include'>"
30) 8, 23
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 1] (8)"
              end: "[3, 8] (15)"
            type: "Include Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(8, 15), match='include'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: true
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 8] (15)"
              end: "[3, 9] (16)"
            type: "HorizontalWhitespace <class 'v1.Lexer.Components.Tokens.HorizontalWhitespaceToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.HorizontalWhitespaceToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 15
                end: 16
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 9] (16)"
              end: "[3, 15] (22)"
            type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(16, 22), match='number'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 15] (22)"
              end: "[4, 1] (23)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 22
                end: 23
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[3, 1] (8)"
          end: "[4, 1] (23)"
        type: "Include <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (8)"
      end: "[4, 1] (23)"
    type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
31) 8, 23
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 1] (8)"
                  end: "[3, 8] (15)"
                type: "Include Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(8, 15), match='include'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: true
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 8] (15)"
                  end: "[3, 9] (16)"
                type: "HorizontalWhitespace <class 'v1.Lexer.Components.Tokens.HorizontalWhitespaceToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.HorizontalWhitespaceToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 15
                    end: 16
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 9] (16)"
                  end: "[3, 15] (22)"
                type: "Lower Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(16, 22), match='number'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 15] (22)"
                  end: "[4, 1] (23)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 22
                    end: 23
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[3, 1] (8)"
              end: "[4, 1] (23)"
            type: "Include <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[3, 1] (8)"
          end: "[4, 1] (23)"
        type: "(Include | Upper | Lower | Number | New Scope) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[3, 1] (8)"
      end: "[4, 1] (23)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
32) 23, 24
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[4, 1] (23)"
      end: "[4, 2] (24)"
    type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(23, 24), match='3'>"
33) 24, 25
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[4, 2] (24)"
      end: "[5, 1] (25)"
    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
        begin: 24
        end: 25
34) 23, 25
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[4, 1] (23)"
          end: "[4, 2] (24)"
        type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
          match: "<_sre.SRE_Match object; span=(23, 24), match='3'>"
      - # <class 'v1.Lexer.Components.AST.Leaf'>
        is_ignored: false
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[4, 2] (24)"
          end: "[5, 1] (25)"
        type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
        value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
          range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
            begin: 24
            end: 25
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[4, 1] (23)"
      end: "[5, 1] (25)"
    type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
35) 23, 24
    # <class 'v1.Lexer.Components.AST.Leaf'>
    is_ignored: false
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[4, 1] (23)"
      end: "[4, 2] (24)"
    type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
      match: "<_sre.SRE_Match object; span=(23, 24), match='3'>"
36) 23, 25
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[4, 1] (23)"
              end: "[4, 2] (24)"
            type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
              match: "<_sre.SRE_Match object; span=(23, 24), match='3'>"
          - # <class 'v1.Lexer.Components.AST.Leaf'>
            is_ignored: false
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[4, 2] (24)"
              end: "[5, 1] (25)"
            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                begin: 24
                end: 25
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[4, 1] (23)"
          end: "[5, 1] (25)"
        type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[4, 1] (23)"
      end: "[5, 1] (25)"
    type: "(Include | Upper | Lower | Number | New Scope) / (Dynamic Number) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
37) 23, 25
    # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[4, 1] (23)"
                  end: "[4, 2] (24)"
                type: "Number Token <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                  match: "<_sre.SRE_Match object; span=(23, 24), match='3'>"
              - # <class 'v1.Lexer.Components.AST.Leaf'>
                is_ignored: false
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[4, 2] (24)"
                  end: "[5, 1] (25)"
                type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                  range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                    begin: 24
                    end: 25
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[4, 1] (23)"
              end: "[5, 1] (25)"
            type: "Number <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[4, 1] (23)"
          end: "[5, 1] (25)"
        type: "(Include | Upper | Lower | Number | New Scope) / (Dynamic Number) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[4, 1] (23)"
      end: "[5, 1] (25)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
