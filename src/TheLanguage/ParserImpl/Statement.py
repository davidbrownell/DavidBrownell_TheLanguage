# ----------------------------------------------------------------------
# |
# |  Statement.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-05-04 14:17:44
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Contains utilities that parse statements"""

import os

from enum import auto, Enum
from typing import cast, Generator, Iterable, List, Optional, Tuple, Union

from dataclasses import dataclass

import CommonEnvironment
from CommonEnvironment import Interface

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from . import Coroutine
    from .NormalizedIterator import NormalizedIterator

    from .Token import Token


# ----------------------------------------------------------------------
class DynamicStatements(Enum):
    """\
    Token that can be used in statements as a placeholder that is populated dynamically at runtime with statements of the corresponding type.

    Example:
        [
            some_keyword_token,
            newline_token,
            indent_token,
            DynamicStatements.Statements,
            dedent_token,
        ]
    """

    Statements                              = auto()    # Statements that do not generate a result
    Expressions                             = auto()    # Statements that generate a result


# ----------------------------------------------------------------------
class Statement(Interface.Interface):
    # ----------------------------------------------------------------------
    ParseResultsType                        = List[
        Union[
            "Statement.TokenParseResultItem",
            "Statement.StatementParseResultItem",
        ],
    ]

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class TokenParseResultItem(object):
        Token: Token

        Whitespace: Optional[Tuple[int, int]]           # Whitespace immediately before the token
        Value: Token.MatchType                          # Result of the call to Token.Match
        Iter: NormalizedIterator                        # NormalizedIterator after the token has been consumed
        IsIgnored: bool                                 # True if the result is whitespace while whitespace is being ignored

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class StatementParseResultItem(object):
        Statement: Union["Statement", DynamicStatements]
        Results: "Statement.ParseResultsType"

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class ParseResult(object):
        Success: bool
        Results: "Statement.ParseResultsType"
        Iter: NormalizedIterator

    # ----------------------------------------------------------------------
    class Observer(Interface.Interface):
        """Observes events generated by calls to Parse"""

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def GetDynamicStatements(
            value: DynamicStatements,
        ) -> List["Statement"]:
            """Returns all currently available dynamic statements based on the current scope"""
            raise Exception("Abstract method")

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def OnIndent():
            raise Exception("Abstract method")

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def OnDedent():
            raise Exception("Abstract method")

    # ----------------------------------------------------------------------
    @classmethod
    def ParseMultipleCoroutine(
        cls,
        statements: Iterable["Statement"],
        normalized_iter: NormalizedIterator,
        observer: Observer,
    ) -> Generator[
        None,
        Coroutine.Status,
        Optional["Statement.ParseResult"],
    ]:
        iterators = [
            (statement_index, statement, statement.ParseCoroutine(normalized_iter.Clone(), observer))
            for statement_index, statement in enumerate(statements)
        ]

        results: List[Optional[Tuple[Statement, Statement.ParseResult]]] = [None] * len(iterators)
        status = Coroutine.Status.Continue

        while True:
            # Process all of the remaining iterators
            iterator_index = 0
            while iterator_index < len(iterators):
                statement_index, statement, iterator = iterators[iterator_index]

                try:
                    next(iterator)
                    iterator.send(status)

                    iterator_index += 1

                except StopIteration as ex:
                    result = ex.value

                    if result is not None:
                        assert results[statement_index] is None, results[statement_index]
                        results[statement_index] = (statement, result)

                    iterators.pop(iterator_index)

            if not iterators:
                break

            # Yield one or more times
            while True:
                this_status = yield

                if this_status == Coroutine.Status.Yield:
                    continue

                if this_status == Coroutine.Status.Terminate:
                    status = this_status

                break

        if status == Coroutine.Status.Terminate:
            return None

        results = cast(List[Tuple[Statement, Statement.ParseResult]], results)

        # Stable sort according to the criteria:
        #   - Success
        #   - Longest matched content

        sort_data = [
            (
                index,
                1 if result.Success else 0,
                result.Iter.Offset,
            )
            for index, (_, result) in enumerate(results)
        ]

        sort_data.sort(
            key=lambda value: value[1:],
            reverse=True,
        )

        statement, result = results[sort_data[0][0]]

        if result.Success:
            return Statement.ParseResult(
                True,
                [
                    Statement.StatementParseResultItem(
                        statement,
                        result.Results,
                    ),
                ],
                result.Iter,
            )

        return_results = []
        max_iter = None

        for statement, result in results:
            return_results.append(Statement.StatementParseResultItem(statement, result.Results))

            if max_iter is None or result.Iter.Offset > max_iter.Offset:
                max_iter = result.Iter

        return Statement.ParseResult(False, return_results, max_iter)

    # ----------------------------------------------------------------------
    @Interface.abstractproperty
    def Name(self):
        """Returns the Name of the derived Statement"""
        raise Exception("Abstract property")

    # ----------------------------------------------------------------------
    @staticmethod
    @Interface.abstractmethod
    def ParseCoroutine(
        normalized_iter: NormalizedIterator,
        observer: Observer,
    ) -> Generator[
        None,
        Coroutine.Status,
        Optional["Statement.ParseResult"],
    ]:
        """Coroutine that parses the provided content"""
        raise Exception("Abstract method")
