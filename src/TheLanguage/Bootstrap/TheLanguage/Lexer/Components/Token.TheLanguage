# ----------------------------------------------------------------------
# |
# |  Token.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-11-09 12:25:56
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
Basic building blocks for token processing.
>>>

from .Normalize import GetNumMultilineTokenDelimiters, multiline_token_delimiter_length
from .NormalizedIterator import NormalizedIterator


# BugBug: # ----------------------------------------------------------------------
# BugBug: private immutable class Token:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Types
# BugBug:     public immutable class MatchResult:
# BugBug:        public NormalizedIterator val iterator
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Data
# BugBug:     [Keyword] public String val name
# BugBug:     [Keyword] public Bool val is_control_token
# BugBug:     [Keyword] public Bool val is_always_ignored
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Methods
# BugBug:     public abstract immutable (MatchResult | None) val Match?(NormalizedIterator var iterator)
# BugBug:
# BugBug:
# BugBug: # ----------------------------------------------------------------------
# BugBug: public immutable class NewlineToken
# BugBug:     extends Token
# BugBug: :
# BugBug:     <<<
# BugBug:     Token that matches 1 or more newlines.
# BugBug:     >>>
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Types
# BugBug:     public immutable class MatchResult
# BugBug:         extends Token::MatchResult
# BugBug:     :
# BugBug:         public UIntArch val start
# BugBug:         public PosIntArch val end
# BugBug:
# BugBug:         # ----------------------------------------------------------------------
# BugBug:         private None __Init?__():
# BugBug:             assert self.start <= self.end
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Data
# BugBug:     [Keyword] public Bool val capture_many
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Methods
# BugBug:     public static NewlineToken val Create(
# BugBug:         Bool val capture_many,
# BugBug:         Bool val is_always_ignored,
# BugBug:     ):
# BugBug:         return NewlineToken(
# BugBug:             name="Newline+" if capture_many else "Newline",
# BugBug:             is_control_token=False,
# BugBug:             is_always_ignored=is_always_ignored,
# BugBug:             capture_many=capture_many,
# BugBug:         )
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
# BugBug:         if iterator.GetNextTokenType() != NormalizedIterator::TokenType::EndOfLine:
# BugBug:             return None
# BugBug:
# BugBug:         val newline_start = iterator.Offset()
# BugBug:
# BugBug:         iterator.Advance(1)
# BugBug:
# BugBug:         if self.capture_many:
# BugBug:             while iterator.IsBlankLine():
# BugBug:                 iterator.SkipLine()
# BugBug:
# BugBug:         return MatchResult(move iterator, newline_start, iterator.Offset())
# BugBug:
# BugBug:
# BugBug: # ----------------------------------------------------------------------
# BugBug: public immutable class IndentToken
# BugBug:     extends Token
# BugBug: :
# BugBug:     <<<
# BugBug:     Token matching indentations of arbitrary length.
# BugBug:     >>>
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Types
# BugBug:     public immutable class MatchResult
# BugBug:         extends Token::MatchResult
# BugBug:     :
# BugBug:         public UIntArch val start
# BugBug:         public PosIntArch val end
# BugBug:         public PosInt val indent_value
# BugBug:
# BugBug:         # ----------------------------------------------------------------------
# BugBug:         private None __Init?__():
# BugBug:             assert self.start <= self.end
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Methods
# BugBug:     public static IndentToken val Create():
# BugBug:         return IndentToken(
# BugBug:             name="Indent",
# BugBug:             is_control_token=False,
# BugBug:             is_always_ignored=False,
# BugBug:         )
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
# BugBug:         if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Indent:
# BugBug:             return None
# BugBug:
# BugBug:         iterator.SkipWhitespacePrefix()
# BugBug:
# BugBug:         val line_info = iterator.LineInfo()
# BugBug:
# BugBug:         assert line_info.new_indentation_value is not None
# BugBug:
# BugBug:         return MatchResult(
# BugBug:             move iterator,
# BugBug:             line_info.offset_start,
# BugBug:             line_info.offset_end,
# BugBug:             line_info.new_indentation_value as PosArch
# BugBug:         )
# BugBug:
# BugBug:
# BugBug: # ----------------------------------------------------------------------
# BugBug: public immutable class DedentToken
# BugBug:     extends Token
# BugBug: :
# BugBug:     <<<
# BugBug:     Token matching a single dedentation.
# BugBug:     >>>
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Types
# BugBug:     public immutable class MatchResult
# BugBug:         extends Token::MatchResult
# BugBug:     :
# BugBug:         pass
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Methods
# BugBug:     public static DedentToken val Create():
# BugBug:         return DedentToken(
# BugBug:             name="Dedent",
# BugBug:             is_control_token=False,
# BugBug:             is_always_ignored=False,
# BugBug:         )
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
# BugBug:         if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Dedent:
# BugBug:             return None
# BugBug:
# BugBug:         iterator.ConsumeDedent()
# BugBug:
# BugBug:         if iterator.GetNextTokenType() == NormalizedIterator::TokenType::WhitespacePrefix:
# BugBug:             iterator.SkipWhitespacePrefix()
# BugBug:
# BugBug:         return MatchResult(move iterator)
# BugBug:
# BugBug:
# BugBug: # ----------------------------------------------------------------------
# BugBug: public immutable class RegexToken
# BugBug:     extends Token
# BugBug: :
# BugBug:     <<<
# BugBug:     Token that matches content against a regular expression.
# BugBug:     >>>
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Types
# BugBug:     public immutable class MatchResult
# BugBug:         extends Token::MatchResult
# BugBug:     :
# BugBug:         public RegexMatch val match
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Data
# BugBug:     [Keyword] public Regex val regex
# BugBug:     [Keyword] public Bool val is_multiline
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Public Methods
# BugBug:     public static RegexToken Create(
# BugBug:         String val name,
# BugBug:         Regex val regex,
# BugBug:         *,
# BugBug:         Bool val is_multiline=False,
# BugBug:         Bool val is_always_ignored=False,
# BugBug:     ):
# BugBug:         return RegexToken(
# BugBug:             name=name,
# BugBug:             is_control_token=False,
# BugBug:             is_always_ignored=is_always_ignored,
# BugBug:             regex=regex,
# BugBug:             is_multiline=is_multiline,
# BugBug:         )
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
# BugBug:         if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Content:
# BugBug:             return None
# BugBug:
# BugBug:         val match = self.regex.Match(
# BugBug:             iterator.Content(),
# BugBug:             start=iterator.Offset(),
# BugBug:             end=iterator.ContentLength() if self.is_multiline else iterator.LineInfo().content_end,
# BugBug:         )
# BugBug:
# BugBug:         if match is None:
# BugBug:             return None
# BugBug:
# BugBug:         val match_length = match.End() - match.Start()
# BugBug:
# BugBug:         if self.is_multiline:
# BugBug:             iterator = _AdvanceMultiline(move iterator, move match_length)
# BugBug:         else:
# BugBug:             iterator.Advance(match_length)
# BugBug:
# BugBug:         return MatchResult(move iterator, match)
# BugBug:
# BugBug:     # ----------------------------------------------------------------------
# BugBug:     # |  Private Methods
# BugBug:     private static NormalizedIterator var _AdvanceMultiline(
# BugBug:         NormalizedIterator var iterator,
# BugBug:         PosInt var delta,
# BugBug:     ):
# BugBug:         while delta:
# BugBug:             while iterator.GetNextTokenType() == NormalizedIterator::TokenType::Dedent:
# BugBug:                 iterator.ConsumeDedent()
# BugBug:
# BugBug:             val this_delta = Min(delta, iterator.LineInfo().offset_end - iterator.Offset())
# BugBug:
# BugBug:             # Delta can be 0 if we are looking at a blank line
# BugBug:             if this_delta != 0:
# BugBug:                 iterator.Advance(this_delta)
# BugBug:                 delta -= this_delta
# BugBug:
# BugBug:             # Skip the newline (if necessary)
# BugBug:             if delta:
# BugBug:                 iterator.Advance(1)
# BugBug:                 delta -= 1
# BugBug:
# BugBug:         return move iterator
# BugBug:
# BugBug:
# BugBug:
# BugBug: # BugBug: ControlTokenBase
# BugBug: # BugBug: PushIgnoreWhitespaceControl
# BugBug: # BugBug: PopIgnoreWhitespaceControl
# BugBug: # BugBug: PushPreserveWhitespaceControl
# BugBug: # BugBug: PopPreserveWhitespaceControl
# BugBug:
