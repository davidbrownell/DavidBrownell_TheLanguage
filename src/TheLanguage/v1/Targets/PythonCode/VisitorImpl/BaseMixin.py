# ----------------------------------------------------------------------
# |
# |  BaseMixin.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2022-04-26 08:36:54
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2022
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Contains the BaseMixin object"""

import os
import textwrap
import types

from io import StringIO
from typing import List, Set, Union

import CommonEnvironment

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from ....Lexer.Location import Location

    from ....Parser.Parser import Region, RootParserInfo

    from ....Parser.ParserInfos.ParserInfo import ParserInfo, VisitControl

    from ....Parser.ParserInfos.Common.ClassModifier import ClassModifier
    from ....Parser.ParserInfos.Common.MethodModifier import MethodModifier
    from ....Parser.ParserInfos.Common.MutabilityModifier import MutabilityModifier
    from ....Parser.ParserInfos.Common.VisibilityModifier import VisibilityModifier

    from ....Parser.ParserInfos.Statements.IfStatementParserInfo import IfStatementParserInfo, StatementParserInfo


# ----------------------------------------------------------------------
class BaseMixin(object):
    """Base class for visitation; implements functionality used by phrase-specific implementations"""

    # ----------------------------------------------------------------------
    def __init__(self):
        imports: Set[str] = set()

        imports.add("from v1.Lexer.Location import Location")
        imports.add("from v1.Parser.Region import Region")
        imports.add("from v1.Parser.ParserInfos.ParserInfo import ParserInfoType")

        for common_import in [
            "ClassModifier",
            "MethodModifier",
            "MutabilityModifier",
            "VisibilityModifier",
        ]:
            imports.add(
                "from v1.Parser.ParserInfos.Common.{common_import} import {common_import}".format(
                    common_import=common_import,
                ),
            )

        self._stream                        = StringIO()
        self._imports                       = imports

        self._scope_level                               = 0
        self._public_exports: List[ParserInfo]          = []

    # ----------------------------------------------------------------------
    def __getattr__(
        self,
        name: str,
    ):
        if name.startswith("OnEnter"):
            return self.__class__._DefaultOnEnterMethod  # pylint: disable=protected-access
        elif name.startswith("OnExit"):
            name = "On{}".format(name[len("OnExit"):])

            method = object.__getattribute__(self, name)
            assert method is not None, name

            return method

        index = name.find("ParserInfo__")
        if index != -1 and index + len("ParserInfo__") + 1 < len(name):
            return types.MethodType(self.__class__._DefaultDetailMethod, self)  # pylint: disable=protected-access

        return None

    # ----------------------------------------------------------------------
    def GetContent(self) -> str:
        return textwrap.dedent(
            """\
            # ----------------------------------------------------------------------
            # This code was automatically generated by the PythonTarget. Any changes made to this
            # file will be overwritten during the next generation!
            # ----------------------------------------------------------------------

            {imports}


            # ----------------------------------------------------------------------
            {content}
            """,
        ).format(
            imports="\n".join(sorted(self._imports)),
            content="\n".join(line.rstrip() for line in self._stream.getvalue().rstrip().splitlines()),
        )

    # ----------------------------------------------------------------------
    @staticmethod
    def OnEnterPhrase(
        parser_info: ParserInfo,  # pylint: disable=unused-argument
    ):
        return VisitControl.Continue

    # ----------------------------------------------------------------------
    def OnExitPhrase(
        self,
        parser_info: ParserInfo,
    ):
        if self._scope_level == 1:
            if isinstance(parser_info, StatementParserInfo):
                should_add = False

                potential_visibility = getattr(parser_info, "visibility", None)
                if potential_visibility is not None:
                    if potential_visibility == VisibilityModifier.public:
                        should_add = True

                elif isinstance(parser_info, IfStatementParserInfo):
                    should_add = True

                else:
                    assert False, type(parser_info)

                if should_add:
                    self._public_exports.append(parser_info)

    # ----------------------------------------------------------------------
    def OnEnterScope(
        self,
        parser_info: ParserInfo,  # pylint: disable=unused-argument
    ) -> None:
        self._scope_level += 1

    # ----------------------------------------------------------------------
    def OnExitScope(
        self,
        parser_info: ParserInfo,  # pylint: disable=unused-argument
    ) -> None:
        assert self._scope_level
        self._scope_level -= 1

    # ----------------------------------------------------------------------
    def OnEnterRootParserInfo(
        self,
        parser_info: RootParserInfo,
    ) -> None:
        if parser_info.documentation is not None:
            self._stream.write(
                textwrap.dedent(
                    '''
                    """\\
                    {}
                    """

                    ''',
                ).format(parser_info.documentation),
            )

    # ----------------------------------------------------------------------
    def OnExitRootParserInfo(
        self,
        parser_info: RootParserInfo,  # pylint: disable=unused-argument
    ) -> None:
        if self._public_exports:
            self._stream.write(
                textwrap.dedent(
                    """\
                    public_exports = [
                        {exports},
                    ]
                    """,
                ).format(
                    exports=",\n    ".join(self._CreateStatementName(pi) for pi in self._public_exports),
                ),
            )

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @staticmethod
    def _CreateStatementName(
        parser_info: ParserInfo,
    ) -> str:
        return "statement{line_begin:0>4}{column_begin:0>4}_{line_end:0>4}{column_end:0>4}".format(
            line_begin=parser_info.regions__.self__.begin.line,
            column_begin=parser_info.regions__.self__.begin.column,
            line_end=parser_info.regions__.self__.end.line,
            column_end=parser_info.regions__.self__.end.column,
        )

    # ----------------------------------------------------------------------
    def _ToString(
        self,
        value: Union[
            None,
            str,
            bool,
            ClassModifier,
            MethodModifier,
            MutabilityModifier,
            VisibilityModifier,
            Location,
            Region,
            ParserInfo,
            List[ParserInfo],
        ],
    ) -> str:
        if value is None:
            return "None"
        elif isinstance(value, str):
            return '"{}"'.format(value.replace("\n", "\\n"))
        elif isinstance(value, bool):
            return str(value)
        elif isinstance(value, ClassModifier):
            return "ClassModifier.{}".format(value.name)
        elif isinstance(value, MethodModifier):
            return "MethodModifier.{}".format(value.name)
        elif isinstance(value, MutabilityModifier):
            return "MutabilityModifier.{}".format(value.name)
        elif isinstance(value, VisibilityModifier):
            return "VisibilityModifier.{}".format(value.name)
        elif isinstance(value, Location):
            return "Location(line={}, column={})".format(value.line, value.column)
        elif isinstance(value, Region):
            return "Region(begin={}, end={})".format(self._ToString(value.begin), self._ToString(value.end))
        elif isinstance(value, ParserInfo):
            return self.__class__._CreateStatementName(value)  # pylint: disable=protected-access
        elif isinstance(value, list):
            return "[{}, ]".format(", ".join(self._ToString(item) for item in value))

        assert False, value
        return None

    # ----------------------------------------------------------------------
    @staticmethod
    def _DefaultOnEnterMethod(
        parser_info: ParserInfo,  # pylint: disable=unused-argument
    ):
        return VisitControl.ContinueWithDetail

    # ----------------------------------------------------------------------
    def _DefaultDetailMethod(
        self,
        parser_info_or_infos: Union[ParserInfo, List[ParserInfo]],
    ):
        if isinstance(parser_info_or_infos, list):
            for parser_info in parser_info_or_infos:
                visit_control = parser_info.Accept(self)

                if visit_control == VisitControl.Terminate:
                    return visit_control

                if visit_control == VisitControl.SkipSiblings:
                    break

            return VisitControl.Continue

        return parser_info_or_infos.Accept(self)
