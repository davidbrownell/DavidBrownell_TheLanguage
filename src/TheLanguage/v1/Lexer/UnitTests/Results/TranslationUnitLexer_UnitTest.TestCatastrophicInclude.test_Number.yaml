# <class 'v1.Lexer.Components.AST.Node'>
children:
  - # <class 'v1.Lexer.Components.AST.Node'>
    children:
      - # <class 'v1.Lexer.Components.AST.Node'>
        children:
          - # <class 'v1.Lexer.Components.AST.Node'>
            children:
              - # <class 'v1.Lexer.Components.AST.Node'>
                children:
                  - # <class 'v1.Lexer.Components.AST.Leaf'>
                    is_ignored: false
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[1, 1] (0)"
                      end: "[1, 8] (7)"
                    type: "include <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                      match: "<_sre.SRE_Match object; span=(0, 7), match='include'>"
                  - # <class 'v1.Lexer.Components.AST.Leaf'>
                    is_ignored: true
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[1, 8] (7)"
                      end: "[1, 9] (8)"
                    type: "HorizontalWhitespace <class 'v1.Lexer.Components.Tokens.HorizontalWhitespaceToken'>"
                    value: # <class 'v1.Lexer.Components.Tokens.HorizontalWhitespaceToken.MatchResult'>
                      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                        begin: 7
                        end: 8
                  - # <class 'v1.Lexer.Components.AST.Leaf'>
                    is_ignored: false
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[1, 9] (8)"
                      end: "[1, 15] (14)"
                    type: "Upper <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                    value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                      match: "<_sre.SRE_Match object; span=(8, 14), match='NUMBER'>"
                  - # <class 'v1.Lexer.Components.AST.Leaf'>
                    is_ignored: false
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[1, 15] (14)"
                      end: "[2, 1] (15)"
                    type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                    value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                      range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                        begin: 14
                        end: 15
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[1, 1] (0)"
                  end: "[2, 1] (15)"
                type: "Include Phrase <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
              - # <class 'v1.Lexer.Components.AST.Node'>
                children:
                  - # <class 'v1.Lexer.Components.AST.Node'>
                    children:
                      - # <class 'v1.Lexer.Components.AST.Node'>
                        children:
                          - # <class 'v1.Lexer.Components.AST.Leaf'>
                            is_ignored: false
                            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                              begin: "[2, 1] (15)"
                              end: "[2, 2] (16)"
                            type: "Number <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                              match: "<_sre.SRE_Match object; span=(15, 16), match='1'>"
                          - # <class 'v1.Lexer.Components.AST.Leaf'>
                            is_ignored: false
                            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                              begin: "[2, 2] (16)"
                              end: "[3, 1] (17)"
                            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                                begin: 16
                                end: 17
                        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                          begin: "[2, 1] (15)"
                          end: "[3, 1] (17)"
                        type: "Number Phrase <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[2, 1] (15)"
                      end: "[3, 1] (17)"
                    type: "(Lower Include Phrase | Number Include Phrase) / (Number Phrase) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[2, 1] (15)"
                  end: "[3, 1] (17)"
                type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
              - # <class 'v1.Lexer.Components.AST.Node'>
                children:
                  - # <class 'v1.Lexer.Components.AST.Node'>
                    children:
                      - # <class 'v1.Lexer.Components.AST.Node'>
                        children:
                          - # <class 'v1.Lexer.Components.AST.Leaf'>
                            is_ignored: false
                            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                              begin: "[3, 1] (17)"
                              end: "[3, 2] (18)"
                            type: "Number <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                              match: "<_sre.SRE_Match object; span=(17, 18), match='2'>"
                          - # <class 'v1.Lexer.Components.AST.Leaf'>
                            is_ignored: false
                            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                              begin: "[3, 2] (18)"
                              end: "[4, 1] (19)"
                            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                                begin: 18
                                end: 19
                        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                          begin: "[3, 1] (17)"
                          end: "[4, 1] (19)"
                        type: "Number Phrase <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[3, 1] (17)"
                      end: "[4, 1] (19)"
                    type: "(Lower Include Phrase | Number Include Phrase) / (Number Phrase) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[3, 1] (17)"
                  end: "[4, 1] (19)"
                type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
              - # <class 'v1.Lexer.Components.AST.Node'>
                children:
                  - # <class 'v1.Lexer.Components.AST.Node'>
                    children:
                      - # <class 'v1.Lexer.Components.AST.Node'>
                        children:
                          - # <class 'v1.Lexer.Components.AST.Leaf'>
                            is_ignored: false
                            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                              begin: "[4, 1] (19)"
                              end: "[4, 2] (20)"
                            type: "Number <class 'v1.Lexer.Components.Tokens.RegexToken'>"
                            value: # <class 'v1.Lexer.Components.Tokens.RegexToken.MatchResult'>
                              match: "<_sre.SRE_Match object; span=(19, 20), match='3'>"
                          - # <class 'v1.Lexer.Components.AST.Leaf'>
                            is_ignored: false
                            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                              begin: "[4, 2] (20)"
                              end: "[5, 1] (21)"
                            type: "Newline+ <class 'v1.Lexer.Components.Tokens.NewlineToken'>"
                            value: # <class 'v1.Lexer.Components.Tokens.NewlineToken.MatchResult'>
                              range: # <class 'v1.Lexer.Components.Normalize.OffsetRange'>
                                begin: 20
                                end: 21
                        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                          begin: "[4, 1] (19)"
                          end: "[5, 1] (21)"
                        type: "Number Phrase <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
                    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                      begin: "[4, 1] (19)"
                      end: "[5, 1] (21)"
                    type: "(Lower Include Phrase | Number Include Phrase) / (Number Phrase) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
                iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
                  begin: "[4, 1] (19)"
                  end: "[5, 1] (21)"
                type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
            iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
              begin: "[1, 1] (0)"
              end: "[5, 1] (21)"
            type: "Number Include Phrase <class 'v1.Lexer.Phrases.SequencePhrase.SequencePhrase'>"
        iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
          begin: "[1, 1] (0)"
          end: "[5, 1] (21)"
        type: "(Lower Include Phrase | Number Include Phrase) <class 'v1.Lexer.Phrases.OrPhrase.OrPhrase'>"
    iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
      begin: "[1, 1] (0)"
      end: "[5, 1] (21)"
    type: "DynamicPhrasesType.Statements <class 'v1.Lexer.Phrases.DynamicPhrase.DynamicPhrase'>"
iter_range: # <class 'v1.Lexer.Components.Phrase.Phrase.NormalizedIteratorRange'>
  begin: "[1, 1] (0)"
  end: "[5, 1] (21)"
type: "<None>"
