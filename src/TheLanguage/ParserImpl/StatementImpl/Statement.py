# ----------------------------------------------------------------------
# |
# |  Statement.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-06-23 08:35:00
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Contains the Statement object"""

import asyncio
import os
import textwrap

from typing import Any, Generator, List, Optional, Tuple, Union

from dataclasses import dataclass

import CommonEnvironment
from CommonEnvironment import Interface
from CommonEnvironment import StringHelpers

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from ..NormalizedIterator import NormalizedIterator
    from ..Token import Token as TokenClass


# ----------------------------------------------------------------------
class Statement(Interface.Interface):
    """Abstract base class for all statement items."""

    # ----------------------------------------------------------------------
    class Observer(Interface.Interface):
        """Observes events generated by calls to Parse"""

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def StartStatement(
            unique_id: List[Any],
        ) -> None:
            """Called before any event is generated for a particular unique_id"""
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def EndStatement(
            unique_id: List[Any],
            was_successful: bool,
        ) -> None:
            """Called when all events have been generated for a particular unique_id"""

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        async def OnIndentAsync(
            unique_id: List[Any],
            iter_before: NormalizedIterator,
            iter_after: NormalizedIterator,
        ) -> None:
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        async def OnDedentAsync(
            unique_id: List[Any],
            iter_before: NormalizedIterator,
            iter_after: NormalizedIterator,
        ) -> None:
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        async def OnInternalStatementAsync(
            unique_id: List[Any],
            statement: "Statement",
            data: Optional["Statement.ParseResultData"],
            iter_before: NormalizedIterator,
            iter_after: NormalizedIterator,
        ) -> bool:                          # True to continue, False to terminate
            """Invoked when an internal statement is successfully matched"""
            raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    # |
    # |  Public Return Types
    # |
    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class ParseResult(Interface.Interface):
        """Result returned by calls to Invoke"""

        Success: bool
        Iter: NormalizedIterator
        Data: Optional["Statement.ParseResultData"]

        # ----------------------------------------------------------------------
        def __str__(self):
            return self.ToString()

        # ----------------------------------------------------------------------
        @Interface.extensionmethod
        def ToString(
            self,
            verbose=False,
        ) -> str:
            return textwrap.dedent(
                """\
                {success}
                {iter}
                    {data}
                """,
            ).format(
                success=self.Success,
                iter=self.Iter.Offset,
                data="<No Data>" if self.Data is None else StringHelpers.LeftJustify(
                    self.Data.ToString(
                        verbose=verbose,
                    ).rstrip(),
                    4,
                ),
            )

    # ----------------------------------------------------------------------
    class ParseResultData(Interface.Interface):
        """Abstract base class for data associated with a ParseResult."""

        # ----------------------------------------------------------------------
        def __str__(self) -> str:
            return self.ToString()

        # ----------------------------------------------------------------------
        @Interface.abstractmethod
        def ToString(
            self,
            verbose=False,
        ) -> str:
            """Displays the object as a string"""
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def Enum() -> Generator[
            Tuple[
                Optional["Statement"],
                Optional["Statement.ParseResultData"],
            ],
            None,
            None
        ]:
            """Enumerates content"""
            raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class StandardParseResultData(ParseResultData):
        """Single statement and data"""

        Statement: "Statement"
        Data: Optional["Statement.ParseResultData"]

        # ----------------------------------------------------------------------
        @Interface.override
        def ToString(
            self,
            verbose=False,
        ) -> str:
            if verbose:
                label = "Data:\n    "
            else:
                label = ""

            return textwrap.dedent(
                """\
                {name}
                    {label}{result}
                """,
            ).format(
                name=self.Statement.ToString(
                    verbose=verbose,
                ),
                label=label,
                result=StringHelpers.LeftJustify(
                    (
                        self.Data.ToString(
                            verbose=verbose,
                        ) if self.Data else str(self.Data)
                    ).rstrip(),
                    4,
                ),
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def Enum(self) -> Generator[
            Tuple[
                Optional["Statement"],
                Optional["Statement.ParseResultData"],
            ],
            None,
            None
        ]:
            yield self.Statement, self.Data

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class MultipleStandardParseResultData(ParseResultData):
        """A collection of StandardParseResultData items"""

        DataItems: List["Statement.StandardParseResultData"]

        # ----------------------------------------------------------------------
        @Interface.override
        def ToString(
            self,
            verbose=False,
        ) -> str:
            data_items = []

            for data_index, data in enumerate(self.DataItems):
                if verbose:
                    prefix = "{}) ".format(data_index) if verbose else ""
                    indent = len(prefix)
                else:
                    prefix = ""
                    indent = 0

                data_items.append(
                    "{}{}".format(
                        prefix,
                        StringHelpers.LeftJustify(
                            data.ToString(
                                verbose=verbose,
                            ).rstrip() if data else str(data),
                            indent,
                        ),
                    ),
                )

            if not data_items:
                data_items.append("<No Items>")

            data_items = "\n".join(data_items)

            if verbose:
                label = "Data:\n"
            else:
                label = ""

            return "{label}{data}\n".format(
                label=label,
                data=data_items,
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def Enum(self) -> Generator[
            Tuple[
                Optional["Statement"],
                Optional["Statement.ParseResultData"],
            ],
            None,
            None
        ]:
            for item in self.DataItems:
                yield from item.Enum()

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class TokenParseResultData(ParseResultData):
        """Result of parsing a token"""

        Token: TokenClass

        Whitespace: Optional[Tuple[int, int]]
        Value: TokenClass.MatchType
        IterBefore: NormalizedIterator
        IterAfter: NormalizedIterator
        IsIgnored: bool

        # ----------------------------------------------------------------------
        @Interface.override
        def ToString(
            self,
            verbose=False,
        ) -> str:
            # BugBug: Figure out a way where parent is not displayed
            return "{name} <<{value}>> ws:{ws}{ignored} [{line_before}, {column_before} -> {line_after}, {column_after}]".format(
                name=self.Token.Name,
                value=str(self.Value),
                ws="None" if self.Whitespace is None else "({}, {})".format(self.Whitespace[0], self.Whitespace[1]),
                ignored=" !Ignored!" if self.IsIgnored else "",
                line_before=self.IterBefore.Line,
                column_before=self.IterBefore.Column,
                line_after=self.IterAfter.Line,
                column_after=self.IterAfter.Column,
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def Enum(self) -> Generator[
            Tuple[
                Optional["Statement"],
                Optional["Statement.ParseResultData"],
            ],
            None,
            None
        ]:
            yield None, self

    # ----------------------------------------------------------------------
    NormalizedIterator                      = NormalizedIterator

    # ----------------------------------------------------------------------
    # |
    # |  Public Methods
    # |
    # ----------------------------------------------------------------------
    def __init__(
        self,
        name: str,
        unique_id: Optional[List[Any]] = None,
        type_id: Optional[int] = None,
    ):
        assert name

        self.Name                           = name
        self.UniqueId                       = unique_id or [name]
        self.TypeId                         = type_id or id(self)

    # ----------------------------------------------------------------------
    def __eq__(self, other):
        for k, v in self.__dict__.items():
            if k == "UniqueId":
                continue
            if k == "TypeId":
                continue
            if k.startswith("_"):
                continue

            other_v = other.__dict__.get(k, Exception)
            if other_v == Exception:
                return False

            if other_v != v:
                return False

        return len(self.__dict__) == len(other.__dict__)

    # ----------------------------------------------------------------------
    def __str__(self):
        return self.ToString()

    # ----------------------------------------------------------------------
    def __hash__(self):
        return id(self)

    # ----------------------------------------------------------------------
    def ToString(
        self,
        verbose=False,
    ) -> str:
        if verbose:
            return "{} <{}>".format(self.Name, ", ".join([str(uid) for uid in self.UniqueId]))

        return self.Name

    # ----------------------------------------------------------------------
    @Interface.abstractmethod
    def Clone(
        self,
        unique_id: List[Any],
    ) -> "Statement":
        """Clones the statement with the new unique_id value"""
        raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    @staticmethod
    @Interface.abstractmethod
    async def ParseAsync(
        normalized_iter: NormalizedIterator,
        observer: Observer,
        ignore_whitespace=False,
        single_threaded=False,
    ) -> Union[
        "Statement.ParseResult",            # Result may or may not be successful
        None,                               # Terminate processing
    ]:
        raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    def Parse(self, *args, **kwargs):
        return asyncio.get_event_loop().run_until_complete(self.ParseAsync(*args, **kwargs))
