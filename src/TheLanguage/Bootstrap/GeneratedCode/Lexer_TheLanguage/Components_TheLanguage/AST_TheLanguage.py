# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String



from .NormalizedIterator_TheLanguage import NormalizedIterator
from .Phrase_TheLanguage import Phrase
from .Token_TheLanguage import Token
# Visibility: private
# ClassModifier: mutable
# ClassType: Class
class _ASTBase(object):
    def __init__(self, *args, **kwargs):
        _ASTBase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # type, is_ignored

        # No bases

        # type
        if "type" in kwargs:
            self.type = kwargs.pop("type")
        elif args:
            self.type = args.pop(0)
        else:
            raise Exception("type was not provided")

        # is_ignored
        if "is_ignored" in kwargs:
            self.is_ignored = kwargs.pop("is_ignored")
        elif args:
            self.is_ignored = args.pop(0)
        else:
            raise Exception("is_ignored was not provided")

        # _parent_
        self._parent_ = None

        self._Init_e4bf6629b851421d9743461303cd9848_()

    def __eq__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        # No bases

        result = cls.__CompareItem__(a.type, b.type, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_ignored, b.is_ignored, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_e4bf6629b851421d9743461303cd9848_(self):
        pass

    @property
    def Type(self): return self.type
    @property
    def IsIgnored(self): return self.is_ignored
    @property
    def Parent(self): return self._parent_
# Visibility: public
# ClassModifier: mutable
# ClassType: Class
class Node(_ASTBase):
    """\
    Result of a matched `Phrase`.
    """

    def __init__(self, *args, **kwargs):
        Node._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        #

        _ASTBase._InternalInit(self, args, kwargs)

        # _children
        self._children = List.Create()

        # _range
        self._range = None

        self._Init_a75a4d9e5fed44fdbab8ec4b806a6810_()

    def __eq__(self, other):
        compare_cache = {}

        if _ASTBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if _ASTBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if _ASTBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if _ASTBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if _ASTBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if _ASTBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = _ASTBase.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a._children, b._children, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a._range, b._range, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_a75a4d9e5fed44fdbab8ec4b806a6810_(self):
        pass

    Phrase_NormalizedIteratorRange = Phrase.NormalizedIteratorRange
    # Return Type: List<<Node | Leaf>, > val
    def ChildrenProper(self):
        return self._children

    # Return Type: Phrase_NormalizedIteratorRange val
    def RangeProper(self):
        return self._range # as Phrase_NormalizedIteratorRange

    @property
    def Children(self): return self._children
    @property
    def IterBegin(self): return self._range.begin
    @property
    def IterEnd(self): return self._range.end
    # Return Type: None
    def AddChild(self, child, ):
        child._parent_ = self
        if True:
            child = child # as val
            if _range is None:
                _range = _RangeData(child.range.begin, child.range.end, )
            else:
                assert _range.__class__.__name__ == "_RangeData"
                if child.range.begin < _range.begin:
                    _range.begin = child.range.begin

                if child.range.end > _range.end:
                    _range.end = child.range.end


            self._children.InsertBack_(child)


    # Return Type: None
    def FinalInit(self):
        assert _range.__class__.__name__ == "_RangeData"
        self._range = Phrase.NormalizedIteratorRange(_range.begin, _range.end, )

    # Visibility: private
    # ClassModifier: mutable
    # ClassType: Struct
    class _RangeData(object):
        def __init__(self, *args, **kwargs):
            Node._RangeData._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # min, max

            # No bases

            # min
            if "min" in kwargs:
                self.min = kwargs.pop("min")
            elif args:
                self.min = args.pop(0)
            else:
                raise Exception("min was not provided")

            # max
            if "max" in kwargs:
                self.max = kwargs.pop("max")
            elif args:
                self.max = args.pop(0)
            else:
                raise Exception("max was not provided")

            self._Init_a4aa7be7e22e49aaa26023ca61732236_()

        def __eq__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            # No bases

            result = cls.__CompareItem__(a.min, b.min, compare_cache)
            if result is not None: return result

            result = cls.__CompareItem__(a.max, b.max, compare_cache)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        def _Init_a4aa7be7e22e49aaa26023ca61732236_(self):
            pass

# Visibility: public
# ClassModifier: mutable
# ClassType: Class
class Leaf(_ASTBase):
    """\
    Result of a matched `Token`.
    """

    def __init__(self, *args, **kwargs):
        args = list(args)
        Leaf._InternalInit(self, args, kwargs)
        assert not args, args
        assert not kwargs, kwargs

    def _InternalInit(self, args, kwargs):
        # value, range

        _ASTBase._InternalInit(self, args, kwargs)

        # value
        if "value" in kwargs:
            self.value = kwargs.pop("value")
        elif args:
            self.value = args.pop(0)
        else:
            raise Exception("value was not provided")

        # range
        if "range" in kwargs:
            self.range = kwargs.pop("range")
        elif args:
            self.range = args.pop(0)
        else:
            raise Exception("range was not provided")

        self._Init_341cad0c2efb4ed591c2d8bdfb8321de_()

    def __eq__(self, other):
        compare_cache = {}

        if _ASTBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if _ASTBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if _ASTBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if _ASTBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if _ASTBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if _ASTBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = _ASTBase.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a.value, b.value, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.range, b.range, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_341cad0c2efb4ed591c2d8bdfb8321de_(self):
        pass

    Token_MatchResult = Token.MatchResult
    Phrase_NormalizedIteratorRange = Phrase.NormalizedIteratorRange
    @property
    def Whitespace(self): return None
    @property
    def Value(self): return self.value
    @property
    def IterBegin(self): return self.range.begin
    @property
    def IterEnd(self): return self.range.end
