# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------
"""\
Basic building blocks for token processing.
"""


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String

    from .Normalize_TheLanguage import GetNumMultilineTokenDelimiters, LineInfo, multiline_token_delimiter_length
    from .NormalizedIterator_TheLanguage import NormalizedIterator

# Visibility: private
# ClassModifier: immutable
# ClassType: Class
class Token(object):
    def __init__(self, *args, **kwargs):
        Token._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # name, is_always_ignored, is_control_token

        # No bases

        # name
        if "name" in kwargs:
            self.name = kwargs.pop("name")
        elif args:
            self.name = args.pop(0)
        else:
            raise Exception("name was not provided")

        # is_always_ignored
        if "is_always_ignored" in kwargs:
            self.is_always_ignored = kwargs.pop("is_always_ignored")
        elif args:
            self.is_always_ignored = args.pop(0)
        else:
            raise Exception("is_always_ignored was not provided")

        # is_control_token
        if "is_control_token" in kwargs:
            self.is_control_token = kwargs.pop("is_control_token")
        elif args:
            self.is_control_token = args.pop(0)
        else:
            raise Exception("is_control_token was not provided")

        self._Init_0d0dca7ee9834d52be91a315c0a08a45_()

    def __eq__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        # No bases

        result = cls.__CompareItem__(a.name, b.name, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_always_ignored, b.is_always_ignored, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_control_token, b.is_control_token, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_0d0dca7ee9834d52be91a315c0a08a45_(self):
        pass

    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(object):
        def __init__(self, *args, **kwargs):
            Token.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # iterator

            # No bases

            # iterator
            if "iterator" in kwargs:
                self.iterator = kwargs.pop("iterator")
            elif args:
                self.iterator = args.pop(0)
            else:
                raise Exception("iterator was not provided")

            self._Init_c639e6ce36be43d4aa3539537147f066_()

        def __eq__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            # No bases

            result = cls.__CompareItem__(a.iterator, b.iterator, compare_cache)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        def _Init_c639e6ce36be43d4aa3539537147f066_(self):
            pass

    @property
    def Name(self): return self.name
    @property
    def IsAlwaysIgnored(self): return self.is_always_ignored
    @property
    def IsControlToken(self): return self.is_control_token
    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        raise Exception("Abstract/Deferred method")

Token_MatchResult = Token.MatchResult
# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class NewlineToken(Token):
    """\
    Token that matches 1 or more newlines.
    """

    def __init__(self, *args, **kwargs):
        NewlineToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # capture_many

        Token._InternalInit(self, args, kwargs)

        # capture_many
        if "capture_many" in kwargs:
            self.capture_many = kwargs.pop("capture_many")
        elif args:
            self.capture_many = args.pop(0)
        else:
            raise Exception("capture_many was not provided")

        self._Init_aee307c0f6d644a6a58f947e1f9a7820_()

    def __eq__(self, other):
        compare_cache = {}

        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Token.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a.capture_many, b.capture_many, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_aee307c0f6d644a6a58f947e1f9a7820_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            NewlineToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end

            NewlineToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            self._Init_1bd301bb2ff5431787e5b1c8b80f02f8_()

        def __eq__(self, other):
            compare_cache = {}

            if NewlineToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            if NewlineToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            if NewlineToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            if NewlineToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            if NewlineToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            if NewlineToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            result = NewlineToken.Token_MatchResult.__Compare__(a, b, compare_cache)
            if result != 0: return result

            result = cls.__CompareItem__(a.start, b.start, compare_cache)
            if result is not None: return result

            result = cls.__CompareItem__(a.end, b.end, compare_cache)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        # Return Type: None
        def _Init_1bd301bb2ff5431787e5b1c8b80f02f8_(self):
            assert self.start <= self.end

    # Return Type: NewlineToken val
    @staticmethod
    def Create(capture_many=True, is_always_ignored=False, ):
        return NewlineToken(name="Newline+" if capture_many else "Newline", is_control_token=False, is_always_ignored=is_always_ignored, capture_many=capture_many, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.EndOfLine:
            return None

        newline_start = iterator.OffsetProper()
        iterator.Advance(1, )
        if self.capture_many:
            while iterator.IsBlankLine():
                iterator.SkipLine()

        return NewlineToken.MatchResult(iterator, newline_start, iterator.OffsetProper(), )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class IndentToken(Token):
    """\
    Token matching indentations of arbitrary length.
    """

    def __init__(self, *args, **kwargs):
        IndentToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_40d07c43dc50434e92873ce4a0e6e0b8_()

    def __eq__(self, other):
        compare_cache = {}

        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Token.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_40d07c43dc50434e92873ce4a0e6e0b8_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            IndentToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end, indent_value

            IndentToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            # indent_value
            if "indent_value" in kwargs:
                self.indent_value = kwargs.pop("indent_value")
            elif args:
                self.indent_value = args.pop(0)
            else:
                raise Exception("indent_value was not provided")

            self._Init_10136a8c23e54a4ba17ddba27a7b1070_()

        def __eq__(self, other):
            compare_cache = {}

            if IndentToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            if IndentToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            if IndentToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            if IndentToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            if IndentToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            if IndentToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            result = IndentToken.Token_MatchResult.__Compare__(a, b, compare_cache)
            if result != 0: return result

            result = cls.__CompareItem__(a.start, b.start, compare_cache)
            if result is not None: return result

            result = cls.__CompareItem__(a.end, b.end, compare_cache)
            if result is not None: return result

            result = cls.__CompareItem__(a.indent_value, b.indent_value, compare_cache)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        # Return Type: None
        def _Init_10136a8c23e54a4ba17ddba27a7b1070_(self):
            assert self.start <= self.end

    # Return Type: IndentToken val
    @staticmethod
    def Create():
        return IndentToken(name="Indent", is_control_token=False, is_always_ignored=False, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Indent:
            return None

        iterator.SkipWhitespacePrefix()
        line_info = iterator.LineInfoProper()
        assert line_info.new_indentation_value is not None
        return IndentToken.MatchResult(iterator, line_info.offset_start, line_info.content_start, line_info.new_indentation_value, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class DedentToken(Token):
    """\
    Token matching a single dedentation.
    """

    def __init__(self, *args, **kwargs):
        DedentToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_724629860e2d4116bcc2d8e0a0b10093_()

    def __eq__(self, other):
        compare_cache = {}

        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Token.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_724629860e2d4116bcc2d8e0a0b10093_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            DedentToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # 

            DedentToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # No members

            self._Init_fbe454219cb14d8a8438b2463911c696_()

        def __eq__(self, other):
            compare_cache = {}

            if DedentToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            if DedentToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            if DedentToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            if DedentToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            if DedentToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            if DedentToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            result = DedentToken.Token_MatchResult.__Compare__(a, b, compare_cache)
            if result != 0: return result



            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        def _Init_fbe454219cb14d8a8438b2463911c696_(self):
            pass

        pass
    # Return Type: DedentToken val
    @staticmethod
    def Create():
        return DedentToken(name="Dedent", is_control_token=False, is_always_ignored=False, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Dedent:
            return None

        iterator.ConsumeDedent()
        if iterator.GetNextTokenType() == NormalizedIterator.TokenType.WhitespacePrefix:
            iterator.SkipWhitespacePrefix()

        return DedentToken.MatchResult(iterator, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class HorizontalWhitespaceToken(Token):
    """\
    Token that matches horizontal whitespace.
    """

    def __init__(self, *args, **kwargs):
        HorizontalWhitespaceToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_514224bbf974493d9e7ba454b7d084ca_()

    def __eq__(self, other):
        compare_cache = {}

        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Token.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_514224bbf974493d9e7ba454b7d084ca_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            HorizontalWhitespaceToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end

            HorizontalWhitespaceToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            self._Init_c87c3a99339a43fdb5b5eb8541f8acfc_()

        def __eq__(self, other):
            compare_cache = {}

            if HorizontalWhitespaceToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            if HorizontalWhitespaceToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            if HorizontalWhitespaceToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            if HorizontalWhitespaceToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            if HorizontalWhitespaceToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            if HorizontalWhitespaceToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            result = HorizontalWhitespaceToken.Token_MatchResult.__Compare__(a, b, compare_cache)
            if result != 0: return result

            result = cls.__CompareItem__(a.start, b.start, compare_cache)
            if result is not None: return result

            result = cls.__CompareItem__(a.end, b.end, compare_cache)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        def _Init_c87c3a99339a43fdb5b5eb8541f8acfc_(self):
            pass

    # Return Type: HorizontalWhitespaceToken val
    @staticmethod
    def Create():
        return HorizontalWhitespaceToken(name="HorizontalWhitespace", is_control_token=False, is_always_ignored=True, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Content:
            return None

        whitespace_range = iterator.GetNextWhitespaceRange()
        if whitespace_range is None or iterator.OffsetProper() != whitespace_range.begin:
            return None

        iterator.Advance(whitespace_range.end - whitespace_range.begin, )
        return HorizontalWhitespaceToken.MatchResult(iterator, whitespace_range.begin, whitespace_range.end, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class RegexToken(Token):
    """\
    Token that matches content against a regular expression.
    """

    def __init__(self, *args, **kwargs):
        RegexToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # regex, is_multiline

        Token._InternalInit(self, args, kwargs)

        # regex
        if "regex" in kwargs:
            self.regex = kwargs.pop("regex")
        elif args:
            self.regex = args.pop(0)
        else:
            raise Exception("regex was not provided")

        # is_multiline
        if "is_multiline" in kwargs:
            self.is_multiline = kwargs.pop("is_multiline")
        elif args:
            self.is_multiline = args.pop(0)
        else:
            raise Exception("is_multiline was not provided")

        self._Init_061fee4045da4e9caf16fd5788a2fb99_()

    def __eq__(self, other):
        compare_cache = {}

        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Token.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a.regex, b.regex, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_multiline, b.is_multiline, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_061fee4045da4e9caf16fd5788a2fb99_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            RegexToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # match

            RegexToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # match
            if "match" in kwargs:
                self.match = kwargs.pop("match")
            elif args:
                self.match = args.pop(0)
            else:
                raise Exception("match was not provided")

            self._Init_51b483fa5fb549bebc541f9430b02146_()

        def __eq__(self, other):
            compare_cache = {}

            if RegexToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) == 0

        def __ne__(self, other):
            compare_cache = {}

            if RegexToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other, compare_cache) != 0

        def __lt__(self, other):
            compare_cache = {}

            if RegexToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) < 0

        def __le__(self, other):
            compare_cache = {}

            if RegexToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) <= 0

        def __gt__(self, other):
            compare_cache = {}

            if RegexToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) > 0

        def __ge__(self, other):
            compare_cache = {}

            if RegexToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other, compare_cache) >= 0

        @classmethod
        def __Compare__(cls, a, b, compare_cache):
            result = RegexToken.Token_MatchResult.__Compare__(a, b, compare_cache)
            if result != 0: return result

            result = cls.__CompareItem__(a.match, b.match, compare_cache)
            if result is not None: return result

            return 0

        @classmethod
        def __CompareItem__(cls, a, b, compare_cache):
            cache_key = (id(a), id(b), )

            cache_value = compare_cache.get(cache_key, None)
            if cache_value is not None:
                return cache_value

            def Impl():
                nonlocal a
                nonlocal b

                if a is None and b is None:
                    return None

                if a is None: return -1
                if b is None: return 1

                try:
                    if a < b: return -1
                    if a > b: return 1
                except TypeError:
                    a = id(a)
                    b = id(b)

                    if a < b: return -1
                    if a > b: return 1

                return None

            result = Impl()

            compare_cache[cache_key] = result
            return result

        def _Init_51b483fa5fb549bebc541f9430b02146_(self):
            pass

    # Return Type: RegexToken
    @staticmethod
    def Create(name, regex, is_multiline=False, is_always_ignored=False, ):
        if is_multiline:
            pattern = regex.pattern.replace("\\", "")
            pattern_len = len(pattern)
            assert GetNumMultilineTokenDelimiters(pattern, start_index=0, end_index=Min(pattern_len, multiline_token_delimiter_length, ), ) == 1, (pattern, "The opening token must be a multiline phrase token", )
            assert GetNumMultilineTokenDelimiters(pattern, start_index=Max(0, pattern_len - multiline_token_delimiter_length, ), end_index=pattern_len, ) == 1, (pattern, "The closing token must be a multiline phrase token", )

        return RegexToken(name=name, is_control_token=False, is_always_ignored=is_always_ignored, regex=regex, is_multiline=is_multiline, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Content:
            return None

        match = self.regex.match(
            iterator.ContentProper(),
            pos=iterator.OffsetProper(),
            endpos=iterator.ContentLengthProper() if self.is_multiline else iterator.LineInfoProper().content_end,
        )
        if match is None:
            return None
        match_length = match.end() - match.start()
        if self.is_multiline:
            iterator = RegexToken._AdvanceMultiline(iterator, match_length, )
        else:
            iterator.Advance(match_length, )

        return RegexToken.MatchResult(iterator, match, )

    # Return Type: NormalizedIterator var
    @staticmethod
    def _AdvanceMultiline(iterator, delta, ):
        while delta:
            while iterator.GetNextTokenType() == NormalizedIterator.TokenType.Dedent:
                iterator.ConsumeDedent()
            this_delta = Min(delta, iterator.LineInfoProper().offset_end - iterator.OffsetProper(), )
            if this_delta != 0:
                iterator.Advance(this_delta, )
                delta -= this_delta

            if delta:
                iterator.Advance(1, )
                delta -= 1

        return iterator

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class ControlTokenBase(Token):
    def __init__(self, *args, **kwargs):
        ControlTokenBase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # closing_token, opening_token

        kwargs["is_control_token"] = True
        kwargs["is_always_ignored"] = False

        Token._InternalInit(self, args, kwargs)

        # closing_token
        if "closing_token" in kwargs:
            self.closing_token = kwargs.pop("closing_token")
        elif args:
            self.closing_token = args.pop(0)
        else:
            raise Exception("closing_token was not provided")

        # opening_token
        if "opening_token" in kwargs:
            self.opening_token = kwargs.pop("opening_token")
        elif args:
            self.opening_token = args.pop(0)
        else:
            raise Exception("opening_token was not provided")

        self._Init_d8c845794748461084b1d3644f5e2a3a_()

    def __eq__(self, other):
        compare_cache = {}

        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Token.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a.is_control_token, b.is_control_token, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.is_always_ignored, b.is_always_ignored, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.closing_token, b.closing_token, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.opening_token, b.opening_token, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        raise Exception("This method should never be invoked for control tokens", )

    # Return Type: None
    def _Init_d8c845794748461084b1d3644f5e2a3a_(self):
        assert ((self.closing_token is not None and self.opening_token is None) or (self.closing_token is None and self.opening_token is not None))

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PushIgnoreWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PushIgnoreWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_6a68ef5d763f4c679855fac6242c77ac_()

    def __eq__(self, other):
        compare_cache = {}

        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = ControlTokenBase.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_6a68ef5d763f4c679855fac6242c77ac_(self):
        pass

    # Return Type: PushIgnoreWhitespaceControlToken
    @staticmethod
    def Create():
        return PushIgnoreWhitespaceControlToken(name="PushIgnoreWhitespaceControl", opening_token=None, closing_token=PopIgnoreWhitespaceControlToken, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PopIgnoreWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PopIgnoreWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_b49319d04da64f24b9be30a700b3a6ae_()

    def __eq__(self, other):
        compare_cache = {}

        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = ControlTokenBase.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_b49319d04da64f24b9be30a700b3a6ae_(self):
        pass

    # Return Type: PopIgnoreWhitespaceControlToken
    @staticmethod
    def Create():
        return PopIgnoreWhitespaceControlToken(name="PopIgnoreWhitespaceControl", opening_token=PushIgnoreWhitespaceControlToken, closing_token=None, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PushPreserveWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PushPreserveWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_5705d181e9394c91825fa9137921f0f7_()

    def __eq__(self, other):
        compare_cache = {}

        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = ControlTokenBase.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_5705d181e9394c91825fa9137921f0f7_(self):
        pass

    # Return Type: PushPreserveWhitespaceControlToken
    @staticmethod
    def Create():
        return PushPreserveWhitespaceControlToken(name="PushPreserveWhitespaceControl", opening_token=None, closing_token=PopPreserveWhitespaceControlToken, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PopPreserveWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PopPreserveWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_5d96379386b1458f9654567282b26ffe_()

    def __eq__(self, other):
        compare_cache = {}

        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = ControlTokenBase.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_5d96379386b1458f9654567282b26ffe_(self):
        pass

    # Return Type: PopPreserveWhitespaceControlToken
    @staticmethod
    def Create():
        return PopPreserveWhitespaceControlToken(name="PopPreserveWhitespaceControl", opening_token=PushPreserveWhitespaceControlToken, closing_token=None, )

