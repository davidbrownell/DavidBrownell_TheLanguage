# ----------------------------------------------------------------------
# |
# |  Phrase.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-12-04 11:02:50
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
Contains the `Phrase` object
>>>

from .Normalize import LineInfo
from .NormalizedIterator import NormalizedIterator
from .Token import Token
from .UniqueId import UniqueId

python_hack: import textwrap
python_hack: from CommonEnvironment import StringHelpers

# BugBug:
#   - Change Phrase visibility to internal
#   - Move this to ../Phrases

# ----------------------------------------------------------------------
public enum DynamicPhrasesType:
    <<<
    BugBug
    >>>

    # TODO: # Standard syntax
    # TODO: Attributes
    # TODO: Expressions
    # TODO: Names
    # TODO: Statements
    # TODO: Types
    # TODO:
    # TODO: # Template syntax
    # TODO: TemplateDecoratorExpressions
    # TODO: TemplateDecoratorTypes

    python_hack: Attributes = auto()
    python_hack: Expressions = auto()
    python_hack: Names = auto()
    python_hack: Statements = auto()
    python_hack: Types = auto()
    python_hack: TemplateDecoratorExpressions = auto()
    python_hack: TemplateDecoratorTypes = auto()


# ----------------------------------------------------------------------
public enum Continuation:
    <<<
    BugBug
    >>>

    # TODO: Continue
    # TODO: Terminate

    python_hack: Continue = auto()
    python_hack: Terminate = auto()


# ----------------------------------------------------------------------
[ProtectedCtor]
# TODO: internal mutable class Phrase:
public mutable class Phrase:
    <<<
    BugBug
    >>>

    python_hack: NormalizedIterator = NormalizedIterator
    python_hack: EnqueueAsyncItemType = None

    # ----------------------------------------------------------------------
    # |
    # |  Public Types
    # |
    # ----------------------------------------------------------------------
    public immutable class NormalizedIteratorRange:
        public NormalizedIterator val begin
        public NormalizedIterator val end

        # ----------------------------------------------------------------------
        private None __Init?__():
            ensure self.begin <= self.end

        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         NormalizedIteratorRange:
        python_hack:           begin:
        python_hack:             {}
        python_hack:           end:
        python_hack:             {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         StringHelpers.LeftJustify(str(self.begin,), 4).rstrip(),
        python_hack:         StringHelpers.LeftJustify(str(self.end), 4).rstrip(),
        python_hack:     )


    # ----------------------------------------------------------------------
    public immutable struct LexResult:
        <<<
        BugBug
        >>>

        public Bool val success
        public NormalizedIteratorRange val range
        public (_LexResultData | None) val data

        python_hack: @property
        python_hack: def Success(self): return self.success
        python_hack: @property
        python_hack: def IterBegin(self): return self.range.begin
        python_hack: @property
        python_hack: def IterEnd(self): return self.range.end
        python_hack: @property
        python_hack: def Data(self): return self.data
        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         LexResult:
        python_hack:           success: {}
        python_hack:           range:
        python_hack:             {}
        python_hack:           data:
        python_hack:             {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         self.success,
        python_hack:         StringHelpers.LeftJustify(str(self.range), 4).rstrip(),
        python_hack:         StringHelpers.LeftJustify(str(self.data), 4).rstrip(),
        python_hack:     )

        # ----------------------------------------------------------------------
        private immutable None __Init?__():
            ensure self.data is not None or self.success is False

    # ----------------------------------------------------------------------
    private immutable class _LexResultData:
        pass

    python_hack: LexResultData = _LexResultData

    # ----------------------------------------------------------------------
    public immutable class WhitespaceLexResultData
        extends _LexResultData
    :
        <<<
        BugBug
        >>>

        python_hack: LineInfo_WhitespaceRange = LineInfo.WhitespaceRange

        # TODO: public LineInfo::WhitespaceRange val whitespace
        public LineInfo_WhitespaceRange val whitespace

        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """
        python_hack:         WhitespaceLexResultData:
        python_hack:           whitespace: {} -> {}
        python_hack:         """.format(self.whitespace.begin, self.whitespace.end),
        python_hack:     )

    # ----------------------------------------------------------------------
    public immutable class TokenLexResultData
        extends _LexResultData
    :
        <<<
        BugBug
        >>>

        python_hack: Token_MatchResult = Token.MatchResult
        python_hack: LineInfo_WhitespaceRange = LineInfo.WhitespaceRange

        public Token val token
        # TODO: public Token.MatchResult val value
        public Token_MatchResult val value
        public NormalizedIteratorRange val range
        [Keyword] public Bool val is_ignored

        python_hack: @property
        python_hack: def Token(self): return self.token
        python_hack: @property
        python_hack: def Whitespace(self): return None
        python_hack: @property
        python_hack: def Value(self): return self.value
        python_hack: @property
        python_hack: def IterBegin(self): return self.range.begin
        python_hack: @property
        python_hack: def IterEnd(self): return self.range.end
        python_hack: @property
        python_hack: def IsIgnored(self): return self.is_ignored
        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         TokenLexResultData:
        python_hack:           token: {}
        python_hack:           value:
        python_hack:             {}
        python_hack:           range:
        python_hack:             {}
        python_hack:           is_ignored: {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         StringHelpers.LeftJustify(str(self.token.name), 4),
        python_hack:         StringHelpers.LeftJustify(str(self.value), 4).rstrip(),
        python_hack:         StringHelpers.LeftJustify(str(self.range), 4).rstrip(),
        python_hack:         StringHelpers.LeftJustify(str(self.is_ignored), 4),
        python_hack:     )

    # ----------------------------------------------------------------------
    public immutable class PhraseLexResultData
        extends _LexResultData
    :
        <<<
        BugBug
        >>>

        public Phrase val phrase
        public (LexResultData | None) val data
        public (UniqueId | None) val unique_id
        public (LexResultData | None) val potential_error_context = None

        python_hack: @property
        python_hack: def Phrase(self): return self.phrase
        python_hack: @property
        python_hack: def Data(self): return self.data
        python_hack: @property
        python_hack: def UniqueId(self): return self.unique_id
        python_hack: @property
        python_hack: def PotentialErrorContext(self): return self.potential_error_context
        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         PhraseLexResultData:
        python_hack:           phrase: {}
        python_hack:           data:
        python_hack:             {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         StringHelpers.LeftJustify(str(self.phrase.Name), 4),
        python_hack:         StringHelpers.LeftJustify(str(self.data), 4).rstrip(),
        python_hack:     )

    # ----------------------------------------------------------------------
    public immutable class PhraseContainerLexResultData
        extends _LexResultData
    :
        <<<
        BugBug
        >>>

        public List<(LexResultData | None)>{ min_length'=0 } val data_items

        python_hack: @property
        python_hack: def DataItems(self): return self.data_items
        python_hack: @property
        python_hack: def IsComplete(self): return True
        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         PhraseContainerLexResultData:
        python_hack:           data_items:
        python_hack:         {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         "\n".join("    - {}".format(StringHelpers.LeftJustify(str(data_item), 6)).rstrip() for data_item in self.data_items),
        python_hack:     )

    python_hack: StandardLexResultData = PhraseLexResultData
    python_hack: MultipleLexResultData = PhraseContainerLexResultData

    # ----------------------------------------------------------------------
    public mutable class Observer:
        <<<
        BugBug
        >>>

        # ----------------------------------------------------------------------
        # |  Public Types
        public immutable struct GetDynamicPhrasesResult:
            public List<Phrase>{ min_length'=0 } val phrases
            public (String | None) val name = None

        # ----------------------------------------------------------------------
        # |  Public Methods
        public abstract mutable GetDynamicPhrasesResult GetDynamicPhrases(
            UniqueId val unique_id,
            DynamicPhrasesType val type,
        ):
            <<<
            BugBug
            >>>

        # ----------------------------------------------------------------------
        public abstract mutable None StartPhrase(UniqueId val unique_id, Phrase val phrase):
            <<<
            BugBug
            >>>

        # ----------------------------------------------------------------------
        public abstract mutable None EndPhrase(UniqueId val unique_id, Phrase val phrase, Bool val was_successful):
            <<<
            BugBug
            >>>

        # ----------------------------------------------------------------------
        public abstract mutable None OnPushScope(PhraseLexResultData val data, NormalizedIteratorRange val range):
            <<<
            BugBug
            >>>

        # ----------------------------------------------------------------------
        public abstract mutable None OnPopScope(PhraseLexResultData val data, NormalizedIteratorRange val range):
            <<<
            BugBug
            >>>

        # ----------------------------------------------------------------------
        public abstract mutable Continuation val OnInternalPhrase(PhraseLexResultData val data, NormalizedIteratorRange val range):
            <<<
            BugBug
            >>>

        python_hack: def OnPushScopeProxy(self, data, range): return self.OnPushScope(data, range.begin, range.end)
        python_hack: def OnPopScopeProxy(self, data, range): return self.OnPopScope(data, range.begin, range.end)
        python_hack: def OnInternalPhraseProxy(self, data, range): return self.OnInternalPhrase(data, range.begin, range.end)

    # ----------------------------------------------------------------------
    # |
    # |  Data
    # |
    # ----------------------------------------------------------------------
    protected String var _name_

    # TODO: name property

    python_hack: @property
    python_hack: def Name(self): return self._name_
    python_hack: @Name.setter
    python_hack: def Name(self, value): self._name_ = value
    python_hack: @property
    python_hack: def Parent(self): return self.ParentProper()
    python_hack: @property
    python_hack: def IsPopulated(self): return self.IsPopulatedProper()
    python_hack: def __hash__(self): return self._name_.__hash__()

    # ----------------------------------------------------------------------
    # |
    # |  Public Methods
    # |
    # ----------------------------------------------------------------------
    # TODO: public var Bool val IsPopulatedProper():
    public immutable Bool val IsPopulatedProper():
        return self._is_populated

    # ----------------------------------------------------------------------
    # TODO: public val (Phrase | None) val ParentProper():
    public immutable (Phrase | None) val ParentProper():
        return self._parent

    # ----------------------------------------------------------------------
    # TODO: public val Bool val PopulateRecursive(
    public mutable Bool val PopulateRecursive(
        (Phrase | None) val parent,
        Phrase val new_phrase,
    ):
        <<<
        BugBug
        >>>

        if self._parent is None:
            self._parent = parent
        else:
            assert self._parent == parent, (
                "A `Phrase` should not be the child of multiple parents; consider constructing the `Phrase` via `PhraseItem` in `../Phrases/DSL.TheLanguage`",
                self._parent.name,
                parent.Name if parent is not None else None,
                self.name,
            )

        if self._is_populated:
            return False

        self._is_populated = True
        return self._PopulateRecursiveImpl(new_phrase)

    # ----------------------------------------------------------------------
    # TODO: public abstract val (LexResult | None) val Lex(
    public abstract immutable (LexResult | None) val Lex(
        any:
            UniqueId val unique_id,
            NormalizedIterator var iter,
            Observer ref observer,
        key:
            Bool val ignore_whitespace=False,
    ):
        <<<
        BugBug
        >>>

    # ----------------------------------------------------------------------
    # |
    # |  Private Data
    # |
    # ----------------------------------------------------------------------
    [NoInit, NoCompare, NoSerialize] private (Phrase | None) var _parent = None
    [NoInit, NoCompare, NoSerialize] private Bool var _is_populated = False

    # ----------------------------------------------------------------------
    # |
    # |  Private Methods
    # |
    # ----------------------------------------------------------------------
    # TODO: private abstract var Bool val _PopulateRecursiveImpl(Phrase val new_phrase):
    private abstract mutable Bool val _PopulateRecursiveImpl(Phrase val new_phrase):
        <<<
        BugBug
        >>>
