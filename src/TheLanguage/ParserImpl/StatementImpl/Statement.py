# ----------------------------------------------------------------------
# |
# |  Statement.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-06-23 08:35:00
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Contains the Statement object"""

import os
import textwrap

from concurrent.futures import Future
from enum import auto, Enum
from typing import Any, Callable, Dict, Generator, List, Optional, Tuple, Union

from dataclasses import dataclass

import CommonEnvironment
from CommonEnvironment import Interface
from CommonEnvironment import StringHelpers

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from ..NormalizedIterator import NormalizedIterator

    from ..Token import (
        RegexToken,
        Token as TokenClass,
    )


# ----------------------------------------------------------------------
class Statement(Interface.Interface):
    """Abstract base class for all statement items."""

    # ----------------------------------------------------------------------
    class Observer(Interface.Interface):
        """Observes events generated by calls to Parse"""

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def Enqueue(
            funcs: List[Callable[[], None]],
        ) -> List[Future]:
            """Enqueues the funcs for execution"""
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def OnIndent(
            data: "Statement.TokenParseResultData",
        ):
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def OnDedent(
            data: "Statement.TokenParseResultData",
        ):
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def OnInternalStatement(
            statement: "Statement",
            data: Optional["Statement.ParseResultData"],
            iter_before: NormalizedIterator,
            iter_after: NormalizedIterator,
        ) -> bool:                          # True to continue, False to terminate
            """Invoked when an internal statement is successfully matched"""
            raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    # |
    # |  Public Return Types
    # |
    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class ParseResult(Interface.Interface):
        """Result returned by calls to Invoke"""

        Success: bool
        Iter: NormalizedIterator
        Data: Optional["Statement.ParseResultData"]

        # ----------------------------------------------------------------------
        @Interface.extensionmethod
        def __str__(self) -> str:
            return textwrap.dedent(
                """\
                {success}
                {iter}
                    {data}
                """,
            ).format(
                success=self.Success,
                iter=self.Iter.Offset,
                data="<No Data>" if self.Data is None else StringHelpers.LeftJustify(str(self.Data).rstrip(), 4),
            )

    # ----------------------------------------------------------------------
    class ParseResultData(Interface.Interface):
        """Abstract base class for data associated with a ParseResult."""

        # ----------------------------------------------------------------------
        @Interface.abstractmethod
        def __str__(self) -> str:
            raise Exception("Abstract method")  # pragma: no cover

        # ----------------------------------------------------------------------
        @staticmethod
        @Interface.abstractmethod
        def EnumTokens() -> Generator["Statement.TokenParseResultData", None, None]:
            raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class StandardParseResultData(ParseResultData):
        """Single statement and data"""

        Statement: "Statement"
        Data: Optional["Statement.ParseResultData"]

        # ----------------------------------------------------------------------
        @Interface.override
        def __str__(self) -> str:
            return textwrap.dedent(
                """\
                {name}
                    {result}
                """,
            ).format(
                name=self.Statement.Name,
                result=StringHelpers.LeftJustify(str(self.Data), 4),
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def EnumTokens(self) -> Generator["Statement.TokenParseResultData", None, None]:
            if self.Data is None:
                return

            yield from self.Data.EnumTokens()

    # ----------------------------------------------------------------------
    @dataclass(frozen=True)
    class TokenParseResultData(ParseResultData):
        Token: TokenClass

        Whitespace: Optional[Tuple[int, int]]
        Value: TokenClass.MatchType
        IterBefore: NormalizedIterator
        IterAfter: NormalizedIterator
        IsIgnored: bool

        # ----------------------------------------------------------------------
        @Interface.override
        def __str__(self) -> str:
            return "{name} <<{value}>> ws:{ws}{ignored} [{line_before}, {column_before} -> {line_after}, {column_after}]".format(
                name=self.Token.Name,
                value=str(self.Value),
                ws="None" if self.Whitespace is None else "({}, {})".format(self.Whitespace[0], self.Whitespace[1]),
                ignored=" !Ignored!" if self.IsIgnored else "",
                line_before=self.IterBefore.Line,
                column_before=self.IterBefore.Column,
                line_after=self.IterAfter.Line,
                column_after=self.IterAfter.Column,
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def EnumTokens(self) -> Generator["Statement.TokenParseResultData", None, None]:
            yield self

    # ----------------------------------------------------------------------
    NormalizedIterator                      = NormalizedIterator

    # ----------------------------------------------------------------------
    # |
    # |  Public Methods
    # |
    # ----------------------------------------------------------------------
    def __init__(
        self,
        name: str,
    ):
        assert name

        self.Name                           = name

    # ----------------------------------------------------------------------
    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    # ----------------------------------------------------------------------
    @staticmethod
    @Interface.abstractmethod
    def Parse(
        normalized_iter: NormalizedIterator,
        observer: Observer,
        ignore_whitespace=False,
        single_threaded=False,
    ) -> Union[
        "Statement.ParseResult",            # Result may or may not be successful
        None,                               # Terminate processing
    ]:
        """Parse the content indicated by the provide iterator"""
        raise Exception("Abstract method")  # pragma: no cover

    # ----------------------------------------------------------------------
    # |
    # |  Protected Types
    # |
    # ----------------------------------------------------------------------
    class QueueCommandObserver(Observer):
        """\
        Captures events so that they can be replayed at a later time.

        We only want to generate events for statements that are successfully parsed.
        For simple Statements, this means that we can send events immediately. However,
        this isn't the case for more complicated Statements; for example, an OrStatement
        should only generate events for a single matching Statement.

        This object can be used to capture events generated and then replay them at a
        later time.
        """

        # ----------------------------------------------------------------------
        def __init__(
            self,
            observer: "Statement.Observer",
        ):
            self._observer                                                  = observer
            self._events: List["Statement.QueueCommandObserver.EventInfo"] = []

        # ----------------------------------------------------------------------
        def Replay(self) -> bool:
            result = True

            for event in self._events:
                if event.Type == Statement.QueueCommandObserver.EventType.Indent:
                    self._observer.OnIndent(*event.Args, **event.Kwargs)
                elif event.Type == Statement.QueueCommandObserver.EventType.Dedent:
                    self._observer.OnDedent(*event.Args, **event.Kwargs)
                elif event.Type == Statement.QueueCommandObserver.EventType.InternalStatement:
                    result = self._observer.OnInternalStatement(*event.Args, **event.Kwargs)
                    if not result:
                        break
                else:
                    assert False, event  # pragma: no cover

            self._events = []
            return result

        # ----------------------------------------------------------------------
        @Interface.override
        def Enqueue(self, *args, **kwargs):
            return self._observer.Enqueue(*args, **kwargs)

        # ----------------------------------------------------------------------
        @Interface.override
        def OnIndent(self, *args, **kwargs):
            self._events.append(
                Statement.QueueCommandObserver.EventInfo(
                    Statement.QueueCommandObserver.EventType.Indent,
                    args,
                    kwargs,
                ),
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def OnDedent(self, *args, **kwargs):
            self._events.append(
                Statement.QueueCommandObserver.EventInfo(
                    Statement.QueueCommandObserver.EventType.Dedent,
                    args,
                    kwargs,
                ),
            )

        # ----------------------------------------------------------------------
        @Interface.override
        def OnInternalStatement(self, *args, **kwargs):
            self._events.append(
                Statement.QueueCommandObserver.EventInfo(
                    Statement.QueueCommandObserver.EventType.InternalStatement,
                    args,
                    kwargs,
                ),
            )

            return True

        # ----------------------------------------------------------------------
        # ----------------------------------------------------------------------
        # ----------------------------------------------------------------------
        class EventType(Enum):
            Indent                          = auto()
            Dedent                          = auto()
            InternalStatement               = auto()

        # ----------------------------------------------------------------------
        @dataclass(frozen=True)
        class EventInfo(object):
            Type: "Statement.QueueCommandObserver.EventType"
            Args: Tuple[Any]
            Kwargs: Dict[str, Any]
