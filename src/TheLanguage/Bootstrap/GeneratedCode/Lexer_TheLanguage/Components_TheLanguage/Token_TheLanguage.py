# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------
"""\
Basic building blocks for token processing.
"""


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String

    from .Normalize_TheLanguage import GetNumMultilineTokenDelimiters, multiline_token_delimiter_length
    from .NormalizedIterator_TheLanguage import NormalizedIterator

# Visibility: private
# ClassModifier: immutable
# ClassType: Class
class Token(object):
    def __init__(self, *args, **kwargs):
        Token._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # name, is_always_ignored, is_control_token

        # No bases

        # name
        if "name" in kwargs:
            self.name = kwargs.pop("name")
        elif args:
            self.name = args.pop(0)
        else:
            raise Exception("name was not provided")

        # is_always_ignored
        if "is_always_ignored" in kwargs:
            self.is_always_ignored = kwargs.pop("is_always_ignored")
        elif args:
            self.is_always_ignored = args.pop(0)
        else:
            raise Exception("is_always_ignored was not provided")

        # is_control_token
        if "is_control_token" in kwargs:
            self.is_control_token = kwargs.pop("is_control_token")
        elif args:
            self.is_control_token = args.pop(0)
        else:
            raise Exception("is_control_token was not provided")

        self._Init_9ad7b1bf948048ffa5690eb4b95d65b2_()

    def __eq__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        # No bases
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        if a.name is None and b.name is None: pass
        elif a.name is None: return -1
        elif b.name is None: return 1
        elif a.name < b.name: return -1
        elif a.name > b.name: return 1

        if a.is_always_ignored is None and b.is_always_ignored is None: pass
        elif a.is_always_ignored is None: return -1
        elif b.is_always_ignored is None: return 1
        elif a.is_always_ignored < b.is_always_ignored: return -1
        elif a.is_always_ignored > b.is_always_ignored: return 1

        if a.is_control_token is None and b.is_control_token is None: pass
        elif a.is_control_token is None: return -1
        elif b.is_control_token is None: return 1
        elif a.is_control_token < b.is_control_token: return -1
        elif a.is_control_token > b.is_control_token: return 1

        return 0

    def _Init_9ad7b1bf948048ffa5690eb4b95d65b2_(self):
        pass

    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(object):
        def __init__(self, *args, **kwargs):
            Token.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # iterator

            # No bases

            # iterator
            if "iterator" in kwargs:
                self.iterator = kwargs.pop("iterator")
            elif args:
                self.iterator = args.pop(0)
            else:
                raise Exception("iterator was not provided")

            self._Init_3100d456995e4120a855d5ac0b6fbd97_()

        def __eq__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            # No bases
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            if a.iterator is None and b.iterator is None: pass
            elif a.iterator is None: return -1
            elif b.iterator is None: return 1
            elif a.iterator < b.iterator: return -1
            elif a.iterator > b.iterator: return 1

            return 0

        def _Init_3100d456995e4120a855d5ac0b6fbd97_(self):
            pass

    @property
    def Name(self): return self.name
    @property
    def IsAlwaysIgnored(self): return self.is_always_ignored
    @property
    def IsControlToken(self): return self.is_control_token
    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        raise Exception("Abstract/Deferred method")

Token_MatchResult = Token.MatchResult
# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class NewlineToken(Token):
    """\
    Token that matches 1 or more newlines.
    """

    def __init__(self, *args, **kwargs):
        NewlineToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # capture_many

        Token._InternalInit(self, args, kwargs)

        # capture_many
        if "capture_many" in kwargs:
            self.capture_many = kwargs.pop("capture_many")
        elif args:
            self.capture_many = args.pop(0)
        else:
            raise Exception("capture_many was not provided")

        self._Init_b1a93f1507c7491b89e1c0e783ffcc8b_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        if a.capture_many is None and b.capture_many is None: pass
        elif a.capture_many is None: return -1
        elif b.capture_many is None: return 1
        elif a.capture_many < b.capture_many: return -1
        elif a.capture_many > b.capture_many: return 1

        return 0

    def _Init_b1a93f1507c7491b89e1c0e783ffcc8b_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            NewlineToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end

            NewlineToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            self._Init_9af7fa857b4c4ce3a174ab154084ec77_()

        def __eq__(self, other):
            if NewlineToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if NewlineToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if NewlineToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if NewlineToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if NewlineToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if NewlineToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            if a.start is None and b.start is None: pass
            elif a.start is None: return -1
            elif b.start is None: return 1
            elif a.start < b.start: return -1
            elif a.start > b.start: return 1

            if a.end is None and b.end is None: pass
            elif a.end is None: return -1
            elif b.end is None: return 1
            elif a.end < b.end: return -1
            elif a.end > b.end: return 1

            return 0

        # Return Type: None
        def _Init_9af7fa857b4c4ce3a174ab154084ec77_(self):
            assert self.start <= self.end

    # Return Type: NewlineToken val
    @staticmethod
    def Create(capture_many=True, is_always_ignored=False, ):
        return NewlineToken(name="Newline+" if capture_many else "Newline", is_control_token=False, is_always_ignored=is_always_ignored, capture_many=capture_many, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.EndOfLine:
            return None

        newline_start = iterator.OffsetProper()
        iterator.Advance(1, )
        if self.capture_many:
            while iterator.IsBlankLine():
                iterator.SkipLine()

        return NewlineToken.MatchResult(iterator, newline_start, iterator.OffsetProper(), )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class IndentToken(Token):
    """\
    Token matching indentations of arbitrary length.
    """

    def __init__(self, *args, **kwargs):
        IndentToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_8dcbf8b55d034dd3893213c9a098bd99_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):


        return 0

    def _Init_8dcbf8b55d034dd3893213c9a098bd99_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            IndentToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # start, end, indent_value

            IndentToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # start
            if "start" in kwargs:
                self.start = kwargs.pop("start")
            elif args:
                self.start = args.pop(0)
            else:
                raise Exception("start was not provided")

            # end
            if "end" in kwargs:
                self.end = kwargs.pop("end")
            elif args:
                self.end = args.pop(0)
            else:
                raise Exception("end was not provided")

            # indent_value
            if "indent_value" in kwargs:
                self.indent_value = kwargs.pop("indent_value")
            elif args:
                self.indent_value = args.pop(0)
            else:
                raise Exception("indent_value was not provided")

            self._Init_1dc957a7fdb2484cb5bf9e0c0dd1e96e_()

        def __eq__(self, other):
            if IndentToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if IndentToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if IndentToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if IndentToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if IndentToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if IndentToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            if a.start is None and b.start is None: pass
            elif a.start is None: return -1
            elif b.start is None: return 1
            elif a.start < b.start: return -1
            elif a.start > b.start: return 1

            if a.end is None and b.end is None: pass
            elif a.end is None: return -1
            elif b.end is None: return 1
            elif a.end < b.end: return -1
            elif a.end > b.end: return 1

            if a.indent_value is None and b.indent_value is None: pass
            elif a.indent_value is None: return -1
            elif b.indent_value is None: return 1
            elif a.indent_value < b.indent_value: return -1
            elif a.indent_value > b.indent_value: return 1

            return 0

        # Return Type: None
        def _Init_1dc957a7fdb2484cb5bf9e0c0dd1e96e_(self):
            assert self.start <= self.end

    # Return Type: IndentToken val
    @staticmethod
    def Create():
        return IndentToken(name="Indent", is_control_token=False, is_always_ignored=False, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Indent:
            return None

        iterator.SkipWhitespacePrefix()
        line_info = iterator.LineInfoProper()
        assert line_info.new_indentation_value is not None
        return IndentToken.MatchResult(iterator, line_info.offset_start, line_info.content_start, line_info.new_indentation_value, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class DedentToken(Token):
    """\
    Token matching a single dedentation.
    """

    def __init__(self, *args, **kwargs):
        DedentToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Token._InternalInit(self, args, kwargs)

        # No members

        self._Init_2c7e57801be64204af303875b845cf3d_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):


        return 0

    def _Init_2c7e57801be64204af303875b845cf3d_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            DedentToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # 

            DedentToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # No members

            self._Init_32a471cf3e1c46499b16ea40122723e8_()

        def __eq__(self, other):
            if DedentToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if DedentToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if DedentToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if DedentToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if DedentToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if DedentToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):


            return 0

        def _Init_32a471cf3e1c46499b16ea40122723e8_(self):
            pass

        pass
    # Return Type: DedentToken val
    @staticmethod
    def Create():
        return DedentToken(name="Dedent", is_control_token=False, is_always_ignored=False, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Dedent:
            return None

        iterator.ConsumeDedent()
        if iterator.GetNextTokenType() == NormalizedIterator.TokenType.WhitespacePrefix:
            iterator.SkipWhitespacePrefix()

        return DedentToken.MatchResult(iterator, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class RegexToken(Token):
    """\
    Token that matches content against a regular expression.
    """

    def __init__(self, *args, **kwargs):
        RegexToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # regex, is_multiline

        Token._InternalInit(self, args, kwargs)

        # regex
        if "regex" in kwargs:
            self.regex = kwargs.pop("regex")
        elif args:
            self.regex = args.pop(0)
        else:
            raise Exception("regex was not provided")

        # is_multiline
        if "is_multiline" in kwargs:
            self.is_multiline = kwargs.pop("is_multiline")
        elif args:
            self.is_multiline = args.pop(0)
        else:
            raise Exception("is_multiline was not provided")

        self._Init_6c4757a276774ef5a5b0db94c77705aa_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        if a.regex is None and b.regex is None: pass
        elif a.regex is None: return -1
        elif b.regex is None: return 1
        elif a.regex < b.regex: return -1
        elif a.regex > b.regex: return 1

        if a.is_multiline is None and b.is_multiline is None: pass
        elif a.is_multiline is None: return -1
        elif b.is_multiline is None: return 1
        elif a.is_multiline < b.is_multiline: return -1
        elif a.is_multiline > b.is_multiline: return 1

        return 0

    def _Init_6c4757a276774ef5a5b0db94c77705aa_(self):
        pass

    Token_MatchResult = Token_MatchResult
    # Visibility: public
    # ClassModifier: immutable
    # ClassType: Class
    class MatchResult(Token_MatchResult):
        def __init__(self, *args, **kwargs):
            RegexToken.MatchResult._InternalInit(self, list(args), kwargs)

        def _InternalInit(self, args, kwargs):
            # match

            RegexToken.Token_MatchResult._InternalInit(self, args, kwargs)

            # match
            if "match" in kwargs:
                self.match = kwargs.pop("match")
            elif args:
                self.match = args.pop(0)
            else:
                raise Exception("match was not provided")

            self._Init_bd5722d63c4a40a4b4d4d86efc4c5b73_()

        def __eq__(self, other):
            if RegexToken.Token_MatchResult.__eq__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) == 0

        def __ne__(self, other):
            if RegexToken.Token_MatchResult.__ne__(self, other) is False: return False
            if not isinstance(other, self.__class__): return True
            return self.__class__.__Compare__(self, other) != 0

        def __lt__(self, other):
            if RegexToken.Token_MatchResult.__lt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) < 0

        def __le__(self, other):
            if RegexToken.Token_MatchResult.__le__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) <= 0

        def __gt__(self, other):
            if RegexToken.Token_MatchResult.__gt__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) > 0

        def __ge__(self, other):
            if RegexToken.Token_MatchResult.__ge__(self, other) is False: return False
            if not isinstance(other, self.__class__): return False
            return self.__class__.__Compare__(self, other) >= 0

        @classmethod
        def __Compare__(cls, a, b):
            if a.match is None and b.match is None: pass
            elif a.match is None: return -1
            elif b.match is None: return 1
            elif a.match < b.match: return -1
            elif a.match > b.match: return 1

            return 0

        def _Init_bd5722d63c4a40a4b4d4d86efc4c5b73_(self):
            pass

    # Return Type: RegexToken
    @staticmethod
    def Create(name, regex, is_multiline=False, is_always_ignored=False, ):
        if is_multiline:
            pattern = regex.pattern.replace("\\", "")
            pattern_len = len(pattern)
            assert GetNumMultilineTokenDelimiters(pattern, start_index=0, end_index=Min(pattern_len, multiline_token_delimiter_length, ), ) == 1, (pattern, "The opening token must be a multiline phrase token", )
            assert GetNumMultilineTokenDelimiters(pattern, start_index=Max(0, pattern_len - multiline_token_delimiter_length, ), end_index=pattern_len, ) == 1, (pattern, "The closing token must be a multiline phrase token", )

        return RegexToken(name=name, is_control_token=False, is_always_ignored=is_always_ignored, regex=regex, is_multiline=is_multiline, )

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        if iterator.GetNextTokenType() != NormalizedIterator.TokenType.Content:
            return None

        match = self.regex.match(
            iterator.ContentProper(),
            pos=iterator.OffsetProper(),
            endpos=iterator.ContentLengthProper() if self.is_multiline else iterator.LineInfoProper().content_end,
        )
        if match is None:
            return None
        match_length = match.end() - match.start()
        if self.is_multiline:
            iterator = RegexToken._AdvanceMultiline(iterator, match_length, )
        else:
            iterator.Advance(match_length, )

        return RegexToken.MatchResult(iterator, match, )

    # Return Type: NormalizedIterator var
    @staticmethod
    def _AdvanceMultiline(iterator, delta, ):
        while delta:
            while iterator.GetNextTokenType() == NormalizedIterator.TokenType.Dedent:
                iterator.ConsumeDedent()
            this_delta = Min(delta, iterator.LineInfoProper().offset_end - iterator.OffsetProper(), )
            if this_delta != 0:
                iterator.Advance(this_delta, )
                delta -= this_delta

            if delta:
                iterator.Advance(1, )
                delta -= 1

        return iterator

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class ControlTokenBase(Token):
    def __init__(self, *args, **kwargs):
        ControlTokenBase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # closing_token, opening_token

        kwargs["is_control_token"] = True
        kwargs["is_always_ignored"] = False

        Token._InternalInit(self, args, kwargs)

        # closing_token
        if "closing_token" in kwargs:
            self.closing_token = kwargs.pop("closing_token")
        elif args:
            self.closing_token = args.pop(0)
        else:
            raise Exception("closing_token was not provided")

        # opening_token
        if "opening_token" in kwargs:
            self.opening_token = kwargs.pop("opening_token")
        elif args:
            self.opening_token = args.pop(0)
        else:
            raise Exception("opening_token was not provided")

        self._Init_93dbca5ad8604cc19ebe0d0bbe896ccf_()

    def __eq__(self, other):
        if Token.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if Token.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if Token.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if Token.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if Token.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if Token.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):
        if a.is_control_token is None and b.is_control_token is None: pass
        elif a.is_control_token is None: return -1
        elif b.is_control_token is None: return 1
        elif a.is_control_token < b.is_control_token: return -1
        elif a.is_control_token > b.is_control_token: return 1

        if a.is_always_ignored is None and b.is_always_ignored is None: pass
        elif a.is_always_ignored is None: return -1
        elif b.is_always_ignored is None: return 1
        elif a.is_always_ignored < b.is_always_ignored: return -1
        elif a.is_always_ignored > b.is_always_ignored: return 1

        if a.closing_token is None and b.closing_token is None: pass
        elif a.closing_token is None: return -1
        elif b.closing_token is None: return 1
        elif a.closing_token < b.closing_token: return -1
        elif a.closing_token > b.closing_token: return 1

        if a.opening_token is None and b.opening_token is None: pass
        elif a.opening_token is None: return -1
        elif b.opening_token is None: return 1
        elif a.opening_token < b.opening_token: return -1
        elif a.opening_token > b.opening_token: return 1

        return 0

    # Return Type: <MatchResult | None> val
    def Match_(self, iterator, ):
        raise Exception("This method should never be invoked for control tokens", )

    # Return Type: None
    def _Init_93dbca5ad8604cc19ebe0d0bbe896ccf_(self):
        assert ((self.closing_token is not None and self.opening_token is None) or (self.closing_token is None and self.opening_token is not None))

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PushIgnoreWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PushIgnoreWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_d666e848395646aa8b5940755b61f809_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):


        return 0

    def _Init_d666e848395646aa8b5940755b61f809_(self):
        pass

    # Return Type: PushIgnoreWhitespaceControlToken
    @staticmethod
    def Create():
        return PushIgnoreWhitespaceControlToken(name="PushIgnoreWhitespaceControl", opening_token=None, closing_token=PopIgnoreWhitespaceControlToken, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PopIgnoreWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PopIgnoreWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_07ecec7c1c6d4149b26de84d0d6ede06_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):


        return 0

    def _Init_07ecec7c1c6d4149b26de84d0d6ede06_(self):
        pass

    # Return Type: PopIgnoreWhitespaceControlToken
    @staticmethod
    def Create():
        return PopIgnoreWhitespaceControlToken(name="PopIgnoreWhitespaceControl", opening_token=PushIgnoreWhitespaceControlToken, closing_token=None, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PushPreserveWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PushPreserveWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_2598cb17034540e5bd1321fc2c51365b_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):


        return 0

    def _Init_2598cb17034540e5bd1321fc2c51365b_(self):
        pass

    # Return Type: PushPreserveWhitespaceControlToken
    @staticmethod
    def Create():
        return PushPreserveWhitespaceControlToken(name="PushPreserveWhitespaceControl", opening_token=None, closing_token=PopPreserveWhitespaceControlToken, )

# Visibility: public
# ClassModifier: immutable
# ClassType: Class
class PopPreserveWhitespaceControlToken(ControlTokenBase):
    """\
    BugBug
    """

    def __init__(self, *args, **kwargs):
        PopPreserveWhitespaceControlToken._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        ControlTokenBase._InternalInit(self, args, kwargs)

        # No members

        self._Init_dd511a07f31f4bf69212bc9d81b33c13_()

    def __eq__(self, other):
        if ControlTokenBase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) == 0

    def __ne__(self, other):
        if ControlTokenBase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other) != 0

    def __lt__(self, other):
        if ControlTokenBase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) < 0

    def __le__(self, other):
        if ControlTokenBase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) <= 0

    def __gt__(self, other):
        if ControlTokenBase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) > 0

    def __ge__(self, other):
        if ControlTokenBase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other) >= 0

    @classmethod
    def __Compare__(cls, a, b):


        return 0

    def _Init_dd511a07f31f4bf69212bc9d81b33c13_(self):
        pass

    # Return Type: PopPreserveWhitespaceControlToken
    @staticmethod
    def Create():
        return PopPreserveWhitespaceControlToken(name="PopPreserveWhitespaceControl", opening_token=PushPreserveWhitespaceControlToken, closing_token=None, )

