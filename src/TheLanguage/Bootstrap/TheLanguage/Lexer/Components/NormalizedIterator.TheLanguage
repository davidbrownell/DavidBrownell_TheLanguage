# ----------------------------------------------------------------------
# |
# |  NormalizedIterator.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-11-08 19:02:17
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
BugBug
>>>

from .Normalize import LineInfo, NormalizedContent

# TODO: Refine these values once python_hack statements are removed


# ----------------------------------------------------------------------
[PrivateCtor]
public mutable class NormalizedIterator:
    <<<
    BugBug
    >>>

    # ----------------------------------------------------------------------
    # |
    # |  Public Types
    # |
    # ----------------------------------------------------------------------
    public enum TokenType:
        # TODO: Dedent
        # TODO: Indent
        # TODO: WhitespacePrefix
        # TODO: Content
        # TODO: WhitespaceSuffix
        # TODO: EndOfLine
        # TODO: EndOfFile

        python_hack: Dedent = 1
        python_hack: Indent = 2
        python_hack: WhitespacePrefix = 3
        python_hack: Content = 4
        python_hack: WhitespaceSuffix = 5
        python_hack: EndOfLine = 6
        python_hack: EndOfFile = 7
        python_hack: def __eq__(self, other): return self.value == other.value

    # ----------------------------------------------------------------------
    # |
    # |  Public Methods
    # |
    # ----------------------------------------------------------------------
    public static NormalizedIterator Create(NormalizedContent val content):
        return NormalizedIterator(
            NormalizedContentEx.Create(content),
            0,
            0,
            0,
            None,
            None,
        )

    # ----------------------------------------------------------------------
    public immutable String val __Repr?__():
        # TODO: return `[{self.Line}, {self.Column}] ({self.Offset})`
        return "[{}, {}] ({})".Format?(self.Line, self.Column, self.Offset)

    # ----------------------------------------------------------------------
    # TODO: Convert to properties

    public immutable String val ContentProper():
        return self._content.content

    public immutable PosInt val ContentLengthProper():
        return self._content.content_length

    public immutable LineInfos val LineInfosProper():
        return self._content.line_infos

    public immutable HashBytes val HashProper():
        return self._content.hash

    public immutable Bool val HasEndOfFileDedentsProper():
        return self._content.has_end_of_file_dedents

    public immutable UIntArch val OffsetProper():
        return self._offset

    public immutable LineInfo val LineInfoProper():
        return self._content.line_infos[self._line_info_index]

    public immutable PosInt val LineProper():
        return self._line_info_index + 1

    public immutable PosInt val ColumnProper():
        if self.AtEnd():
            return 1

        return self._offset - self.LineInfoProper().offset_start + 1

    python_hack: LineInfo_WhitespaceRange = LineInfo.WhitespaceRange

    # TODO: public immutable (LineInfo::WhitespaceRange | None) val NextWhitespaceRangeProper():
    public immutable (LineInfo_WhitespaceRange | None) val NextWhitespaceRangeProper():

        if self.AtEnd():
            return None

        val whitespace_ranges = self.LineInfoProper().WhitespaceRanges()

        if self._whitespace_range_index >= whitespace_ranges.Length():
            return None

        return whitespace_ranges[self._whitespace_range_index]

    python_hack: @property
    python_hack: def Content(self):
    python_hack:     return self.ContentProper()
    python_hack: @property
    python_hack: def ContentLength(self):
    python_hack:     return self.ContentLengthProper()
    python_hack: @property
    python_hack: def LineInfos(self):
    python_hack:     return self.LineInfosProper()
    python_hack: @property
    python_hack: def Hash(self):
    python_hack:     return self.HashProper()
    python_hack: @property
    python_hack: def HasEndOfFileDedents(self):
    python_hack:     return self.HasEndOfFileDedentsProper()
    python_hack: @property
    python_hack: def Offset(self):
    python_hack:     return self.OffsetProper()
    python_hack: @property
    python_hack: def LineInfo(self):
    python_hack:     return self.LineInfoProper()
    python_hack: @property
    python_hack: def Line(self):
    python_hack:     return self.LineProper()
    python_hack: @property
    python_hack: def Column(self):
    python_hack:     return self.ColumnProper()

    # ----------------------------------------------------------------------
    public immutable (
        HashBytes,
        UIntArch,
        UintArch,
        (UIntArch | None),
        (UIntArch | None),
    ) ToCacheKey():
        return (
            self.Hash(),
            self.OffsetProper(),
            self._whitespace_range_index.Clone(),
            self._consumed_dedent_line.Clone(),
            self._consumed_dedent_count.Clone(),
        )

    # ----------------------------------------------------------------------
    public immutable Bool val AtEnd():
        val line_infos = self.LineInfosProper()

        if self._line_info_index == len(line_infos):
            return True

        if (
            self.HasEndOfFileDedentsProper()
            and self._line_info_index == len(line_infos) - 1
            and self._consumed_dedent_line == self._line_info_index
            and self._consumed_dedent_count == self.LineInfoProper().num_dedents
        ):
            return True

        return False

    # ----------------------------------------------------------------------
    public immutable TokenType val GetNextTokenType():
        if self.AtEnd():
            return TokenType.EndOfFile

        val line_info = self.LineInfoProper()

        if (
            line_info.num_dedents is not None
            and (
                self._consumed_dedent_line != self._line_info_index
                or self._consumed_dedent_count != line_info.num_dedents
            )
        ):
            return TokenType.Dedent

        if self._offset < line_info.content_start:
            if line_info.new_indentation_value is not None:
                return TokenType.Indent

            return TokenType.WhitespacePrefix

        if self._offset < line_info.content_end:
            return TokenType.Content

        if self._offset >= line_info.content_end and self._offset < line_info.offset_end:
            return TokenType.WhitespaceSuffix

        assert self._offset == line_info.offset_end
        return TokenType.EndOfLine

    # ----------------------------------------------------------------------
    public immutable Bool val IsBlankLine():
        # We don't have a line when we are at the end, so it can't be a blank line by definition.
        if self.AtEnd():
            return False

        # The trailing dedent lines should not be considered blank lines
        if (
            self._line_info_index == len(self.LineInfosProper()) - 1
            and self.HasEndOfFileDedentsProper()
        ):
            return False

        val line_info = self.LineInfoProper()

        return line_info.content_end == line_info.content_start

    # ----------------------------------------------------------------------
    public mutable None ConsumeDedent():
        assert self.LineInfoProper().num_dedents is not None
        assert self.OffsetProper() == self.LineInfoProper().offset_start

        if self._consumed_dedent_line != self._line_info_index:
            self._consumed_dedent_line = self._line_info_index # TODO
            self._consumed_dedent_count = 0 # TODO

        # TODO: assert self._consumed_dedent_count is Int
        self._consumed_dedent_count += 1

    # ----------------------------------------------------------------------
    public mutable None SkipLine():
        self._offset = self.LineInfoProper().offset_end

        self.Advance(1)

    # ----------------------------------------------------------------------
    public mutable None SkipWhitespacePrefix():
        val offset = self._offset
        val line_info = self.LineInfoProper()

        assert offset == line_info.offset_start

        val delta = line_info.content_start - offset

        if delta != 0:
            self.Advance(delta)

    # ----------------------------------------------------------------------
    public mutable None SkipWhitespaceSuffix():
        val offset = self._offset
        val line_info = self.LineInfoProper()

        assert offset == line_info.content_end

        val delta = line_info.offset_end - offset

        if delta != 0:
            self.Advance(delta)

    # ----------------------------------------------------------------------
    public mutable None Advance(PosIntArch val delta):
        <<<
        Advances the offset within a line or moves to a new line if delta == 1.
        >>>

        val offset = self._offset
        val line_info = self.LineInfoProper()

        if offset == line_info.offset_end:
            assert delta == 1
            assert self.GetNextTokenType() == TokenType.EndOfLine

            self._line_info_index += 1
            self._whitespace_range_index = 0

        else:
            assert offset >= line_info.offset_start and offset <= line_info.offset_end, "The offset should be within the current line"
            assert offset + delta <= line_info.offset_end, "The delta should not move us past the current line"
            assert (
                offset >= line_info.content_start                                       # (A)
                or (
                    offset == line_info.offset_start
                    and (
                        offset + delta == line_info.content_start                       # (B)
                        or delta == line_info.offset_end - line_info.offset_start       # (C)
                    )
                )
            ), "We are looking at content (A), at the beginning of the line and are skipping the whitespace prefix (B) or are skipping the contents on the line (C) <but not the newline itself>"

        self._offset += delta

        # Determine if applying the delta indicates that we are looking at a new whitespace range.
        if self._offset != self._content.content_length:
            val whitespace_ranges = self.LineInfoProper().whitespace_ranges
            val whitespace_ranges_len = whitespace_ranges.Length() # TODO: Only necessary because Length syntax is wonky

            while (
                # TODO: self._whitespace_range_index < whitespace_ranges.Length()
                self._whitespace_range_index < whitespace_ranges_len
                and self._offset > whitespace_ranges[self._whitespace_range_index].begin
            ):
                self._whitespace_range_index += 1

    # ----------------------------------------------------------------------
    # |
    # |  Private Types
    # |
    # ----------------------------------------------------------------------
    [PrivateCtor]
    private immutable class NormalizedContentEx
        extends NormalizedContent
    :
        <<<
        Adds end-of-file-dedent info to NormalizedContent
        >>>

        [NoInit] public Bool val has_end_of_file_dedents

        # ----------------------------------------------------------------------
        public static NormalizedContentEx val Create(NormalizedContent val content):
            # TODO: Long term, we should be able to construct based on an instance and not have to deconstruct and reconstruct the value as we are doing here
            return NormalizedContentEx(
                content.content,
                content.content_length,
                content.line_infos,
                content.hash,
            )

        # ----------------------------------------------------------------------
        private None __Init?__():
            val last_line_info = self.line_infos[-1]

            self.has_end_of_file_dedents = (
                last_line_info.num_dedents is not None
                and last_line_info.num_dedents > 0
                and last_line_info.offset_start == last_line_info.offset_end
                and last_line_info.content_start == last_line_info.offset_start
                and last_line_info.content_end == last_line_info.offset_end
            )

    python_hack: def Clone(self):
    python_hack:     return self.__class__(self._content, self._offset, self._line_info_index, self._whitespace_range_index, self._consumed_dedent_line, self._consumed_dedent_count)

    # ----------------------------------------------------------------------
    # |
    # |  Private Data
    # |
    # ----------------------------------------------------------------------
    private NormalizedContentEx val _content

    private UIntArch var _offset
    private UIntArch var _line_info_index

    private UIntArch var _whitespace_range_index

    # BugBug: I don't think that _consumed_dedent_line is necessary if the count is reset in Advance; similar to what is done with _whitespace_range_index
    private (UIntArch | None) var _consumed_dedent_line
    private (UIntArch | None) var _consumed_dedent_count

    # ----------------------------------------------------------------------
    # |
    # |  Private Methods
    # |
    # ----------------------------------------------------------------------
    private None __Init?__():
        ensure self._offset <= self._content.content_length

        if self._offset != self._content.content_length:
            # TODO (Length syntax is wonky): ensure self._line_info_index < self._content.line_infos.Length()
            val line_info = self._content.line_infos[self._line_info_index]

            # TODO (Length syntax is wonky): ensure self._whitespace_range_index < line_info.whitespace_ranges.Length()

        # TODO (Length syntax is wonky): ensure self._consumed_dedent_line is None or self._consumed_dedent_line < self._content.line_infos.Length()
        ensure (
            (self._consumed_dedent_count is None and self._consumed_dedent_line is None)
            or (self._consumed_dedent_count is not None and self._consumed_dedent_line is not None)
        )


python_hack: NormalizedContentEx = NormalizedIterator.NormalizedContentEx
python_hack: TokenType = NormalizedIterator.TokenType
