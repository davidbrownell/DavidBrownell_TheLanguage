# ----------------------------------------------------------------------
# |
# |  Token.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-11-09 12:25:56
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
Basic building blocks for token processing.
>>>

from .Normalize import GetNumMultilineTokenDelimiters, LineInfo, multiline_token_delimiter_length
from .NormalizedIterator import NormalizedIterator

python_hack: import textwrap
python_hack: from CommonEnvironment import StringHelpers


# ----------------------------------------------------------------------
[ProtectedCtor]
private immutable class Token:
    # ----------------------------------------------------------------------
    # |  Public Types
    public immutable class MatchResult:
       public NormalizedIterator val iterator

    # ----------------------------------------------------------------------
    # |  Public Data
    [Keyword] public String val name
    [Keyword] public Bool val is_always_ignored
    [Keyword] public Bool val is_control_token

    python_hack: @property
    python_hack: def Name(self): return self.name
    python_hack: @property
    python_hack: def IsAlwaysIgnored(self): return self.is_always_ignored
    python_hack: @property
    python_hack: def IsControlToken(self): return self.is_control_token

    # ----------------------------------------------------------------------
    # |  Public Methods
    public abstract immutable (MatchResult | None) val Match?(NormalizedIterator var iterator)

python_hack: Token_MatchResult = Token.MatchResult


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class NewlineToken
    extends Token
:
    <<<
    Token that matches 1 or more newlines.
    >>>

    python_hack: Token_MatchResult = Token_MatchResult

    # ----------------------------------------------------------------------
    # |  Public Types
    public immutable class MatchResult
        # TODO: extends Token::MatchResult
        extends Token_MatchResult
    :
        public UIntArch val start
        public PosIntArch val end

        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         NewlineToken.MatchResult:
        python_hack:           start: {}
        python_hack:           end: {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         self.start,
        python_hack:         self.end,
        python_hack:     )

        # ----------------------------------------------------------------------
        private None __Init?__():
            ensure self.start <= self.end

    # ----------------------------------------------------------------------
    # |  Public Data
    [Keyword] public Bool val capture_many

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static NewlineToken val Create(
        key:
            Bool val capture_many=True,
            Bool val is_always_ignored=False,
    ):
        return NewlineToken(
            name="Newline+" if capture_many else "Newline",
            is_control_token=False,
            is_always_ignored=is_always_ignored,
            capture_many=capture_many,
        )

    # ----------------------------------------------------------------------
    public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
        if iterator.GetNextTokenType() != NormalizedIterator::TokenType::EndOfLine:
            return None

        val newline_start = iterator.OffsetProper()

        iterator.Advance(1)

        if self.capture_many:
            while iterator.IsBlankLine():
                iterator.SkipLine()

        # TODO: return MatchResult(move iterator, newline_start, iterator.OffsetProper())
        return NewlineToken.MatchResult(move iterator, newline_start, iterator.OffsetProper())


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class IndentToken
    extends Token
:
    <<<
    Token matching indentations of arbitrary length.
    >>>

    python_hack: Token_MatchResult = Token_MatchResult

    # ----------------------------------------------------------------------
    # |  Public Types
    public immutable class MatchResult
        # TODO: extends Token::MatchResult
        extends Token_MatchResult
    :
        public UIntArch val start
        public PosIntArch val end
        public PosInt val indent_value

        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         IndentToken.MatchResult:
        python_hack:           start: {}
        python_hack:           end: {}
        python_hack:           indent_value: {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         self.start,
        python_hack:         self.end,
        python_hack:         self.indent_value,
        python_hack:     )

        # ----------------------------------------------------------------------
        private None __Init?__():
            ensure self.start <= self.end

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static IndentToken val Create():
        return IndentToken(
            name="Indent",
            is_control_token=False,
            is_always_ignored=False,
        )

    # ----------------------------------------------------------------------
    public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
        if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Indent:
            return None

        iterator.SkipWhitespacePrefix()

        val line_info = iterator.LineInfoProper()

        assert line_info.new_indentation_value is not None

        # TODO: return MatchResult(
        return IndentToken.MatchResult(
            move iterator,
            line_info.offset_start,
            line_info.content_start,
            # TODO: line_info.new_indentation_value as PosArch
            line_info.new_indentation_value # The cast is generated as a comment in Python, which cases the closing paren to be a comment as well
        )


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class DedentToken
    extends Token
:
    <<<
    Token matching a single dedentation.
    >>>

    python_hack: Token_MatchResult = Token_MatchResult

    # ----------------------------------------------------------------------
    # |  Public Types
    public immutable class MatchResult
        # TODO: extends Token::MatchResult
        extends Token_MatchResult
    :
        pass

        python_hack: def __str__(self):
        python_hack:     return "DedentToken.MatchResult"

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static DedentToken val Create():
        return DedentToken(
            name="Dedent",
            is_control_token=False,
            is_always_ignored=False,
        )

    # ----------------------------------------------------------------------
    public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
        if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Dedent:
            return None

        iterator.ConsumeDedent()

        if iterator.GetNextTokenType() == NormalizedIterator::TokenType::WhitespacePrefix:
            iterator.SkipWhitespacePrefix()

        # TODO: return MatchResult(move iterator)
        return DedentToken.MatchResult(move iterator)


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class HorizontalWhitespaceToken
    extends Token
:
    <<<
    Token that matches horizontal whitespace.
    >>>

    python_hack: Token_MatchResult = Token_MatchResult

    # ----------------------------------------------------------------------
    # |  Public Types
    public immutable class MatchResult
        # TODO: extends Token::MatchResult
        extends Token_MatchResult
    :
        public UIntArch val start
        public PosIntArch val end

        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         HorizontalWhitespaceToken.MatchResult:
        python_hack:           start: {}
        python_hack:           end: {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         self.start,
        python_hack:         self.end,
        python_hack:     )

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static HorizontalWhitespaceToken val Create():
        return HorizontalWhitespaceToken(
            name="HorizontalWhitespace",
            is_control_token=False,
            is_always_ignored=True,
        )

    # ----------------------------------------------------------------------
    public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
        if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Content:
            return None

        val whitespace_range = iterator.GetNextWhitespaceRange()

        if whitespace_range is None or iterator.OffsetProper() != whitespace_range.begin:
            return None

        iterator.Advance(whitespace_range.end - whitespace_range.begin)

        # TODO: return MatchResult(move iterator)
        return HorizontalWhitespaceToken.MatchResult(
            move iterator,
            whitespace_range.begin,
            whitespace_range.end,
        )


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class RegexToken
    extends Token
:
    <<<
    Token that matches content against a regular expression.
    >>>

    python_hack: Token_MatchResult = Token_MatchResult

    # ----------------------------------------------------------------------
    # |  Public Types
    public immutable class MatchResult
        # TODO: extends Token::MatchResult
        extends Token_MatchResult
    :
        public RegexMatch val match

        python_hack: def __str__(self):
        python_hack:     return textwrap.dedent(
        python_hack:         """\
        python_hack:         RegexToken.MatchResult:
        python_hack:           match: {}
        python_hack:         """,
        python_hack:     ).format(
        python_hack:         self.match,
        python_hack:     )

    # ----------------------------------------------------------------------
    # |  Public Data
    [Keyword] public Regex val regex
    [Keyword] public Bool val is_multiline

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static RegexToken Create(
        any:
            String val name,
            Regex val regex,
        key:
            Bool val is_multiline=False,
            Bool val is_always_ignored=False,
    ):
        if is_multiline:
            # Note that these checks are only checking that there is an opening
            # and closing token, but not that the entirety of the tokens are valid
            # (for example, the invalid token "<<<!!" would not be detected).
            # Take special care when working with multiline RegexTokens.

            # TODO: val pattern = regex.Pattern()
            # TODO: val pattern_len = pattern.Length()
            python_hack: pattern = regex.pattern.replace("\\", "")
            python_hack: pattern_len = len(pattern)

            # Check the opening token
            assert GetNumMultilineTokenDelimiters(
                pattern,
                start_index=0,
                end_index=Min(pattern_len, multiline_token_delimiter_length),
            ) == 1, (pattern, "The opening token must be a multiline phrase token")

            # Check the closing token
            assert GetNumMultilineTokenDelimiters(
                pattern,
                start_index=Max(0, pattern_len - multiline_token_delimiter_length),
                end_index=pattern_len,
            ) == 1, (pattern, "The closing token must be a multiline phrase token")

        return RegexToken(
            name=name,
            is_control_token=False,
            is_always_ignored=is_always_ignored,
            regex=regex,
            is_multiline=is_multiline,
        )

    # ----------------------------------------------------------------------
    public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
        if iterator.GetNextTokenType() != NormalizedIterator::TokenType::Content:
            return None

        # TODO: val match = self.regex.Match(
        # TODO:     iterator.Content(),
        # TODO:     start=iterator.Offset(),
        # TODO:     end=iterator.ContentLength() if self.is_multiline else iterator.LineInfo().content_end,
        # TODO: )
        # TODO:
        # TODO: if match is None:
        # TODO:     return None
        # TODO:
        # TODO: val match_length = match.End() - match.Start()

        python_hack: match = self.regex.match(
        python_hack:     iterator.ContentProper(),
        python_hack:     pos=iterator.OffsetProper(),
        python_hack:     endpos=iterator.ContentLengthProper() if self.is_multiline else iterator.LineInfoProper().content_end,
        python_hack: )
        python_hack: if match is None:
        python_hack:     return None
        python_hack: match_length = match.end() - match.start()

        if self.is_multiline:
            iterator = RegexToken::_AdvanceMultiline(move iterator, move match_length)
        else:
            iterator.Advance(match_length)

        # TODO: return MatchResult(move iterator, match)
        return RegexToken.MatchResult(move iterator, match)

    # ----------------------------------------------------------------------
    # |  Private Methods
    private static NormalizedIterator var _AdvanceMultiline(
        NormalizedIterator var iterator,
        PosInt var delta,
    ):
        while delta:
            while iterator.GetNextTokenType() == NormalizedIterator::TokenType::Dedent:
                iterator.ConsumeDedent()

            val this_delta = Min(delta, iterator.LineInfoProper().offset_end - iterator.OffsetProper())

            # Delta can be 0 if we are looking at a blank line
            if this_delta != 0:
                iterator.Advance(this_delta)
                delta -= this_delta

            # Skip the newline (if necessary)
            if delta:
                iterator.Advance(1)
                delta -= 1

        return move iterator


# ----------------------------------------------------------------------
[ProtectedCtor]
public immutable class ControlTokenBase
    extends Token
:
    [Override] public Bool val is_control_token = True
    [Override] public Bool val is_always_ignored = False

    [Keyword] public (ControlTokenBase | None) val closing_token
    [Keyword] public (ControlTokenBase | None) val opening_token

    # ----------------------------------------------------------------------
    # |  Public Methods
    public override immutable (MatchResult | None) val Match?(NormalizedIterator var iterator):
        raise Exception("This method should never be invoked for control tokens")

    # ----------------------------------------------------------------------
    # |  Private Methods
    private None __Init?__():
        ensure (
            (self.closing_token is not None and self.opening_token is None)
            or (self.closing_token is None and self.opening_token is not None)
        )


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class PushIgnoreWhitespaceControlToken
    extends ControlTokenBase
:
    <<<
    BugBug
    >>>

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static PushIgnoreWhitespaceControlToken Create():
        return PushIgnoreWhitespaceControlToken(
            name="PushIgnoreWhitespaceControl",
            opening_token=None,
            closing_token=PopIgnoreWhitespaceControlToken,
        )


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class PopIgnoreWhitespaceControlToken
    extends ControlTokenBase
:
    <<<
    BugBug
    >>>

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static PopIgnoreWhitespaceControlToken Create():
        return PopIgnoreWhitespaceControlToken(
            name="PopIgnoreWhitespaceControl",
            opening_token=PushIgnoreWhitespaceControlToken,
            closing_token=None,
        )


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class PushPreserveWhitespaceControlToken
    extends ControlTokenBase
:
    <<<
    BugBug
    >>>

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static PushPreserveWhitespaceControlToken Create():
        return PushPreserveWhitespaceControlToken(
            name="PushPreserveWhitespaceControl",
            opening_token=None,
            closing_token=PopPreserveWhitespaceControlToken,
        )


# ----------------------------------------------------------------------
[PrivateCtor]
public immutable class PopPreserveWhitespaceControlToken
    extends ControlTokenBase
:
    <<<
    BugBug
    >>>

    # ----------------------------------------------------------------------
    # |  Public Methods
    public static PopPreserveWhitespaceControlToken Create():
        return PopPreserveWhitespaceControlToken(
            name="PopPreserveWhitespaceControl",
            opening_token=PushPreserveWhitespaceControlToken,
            closing_token=None,
        )
