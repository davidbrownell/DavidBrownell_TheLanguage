# ----------------------------------------------------------------------
# |
# |  NormalizedIterator.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-11-08 19:02:17
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
BugBug
>>>

from .Normalize import LineInfo, NormalizedContent


# ----------------------------------------------------------------------
[PrivateCtor]
public mutable class NormalizedIterator:
    <<<
    BugBug
    >>>

    # ----------------------------------------------------------------------
    # |
    # |  Public Types
    # |
    # ----------------------------------------------------------------------
    public enum TokenType:
        # TODO: Dedent
        # TODO: Indent
        # TODO: WhitespacePrefix
        # TODO: Content
        # TODO: WhitespaceSuffix
        # TODO: EndOfLine
        # TODO: EndOfFile

        python_hack: Dedent = 1
        python_hack: Indent = 2
        python_hack: WhitespacePrefix = 3
        python_hack: Content = 4
        python_hack: WhitespaceSuffix = 5
        python_hack: EndOfLine = 6
        python_hack: EndOfFile = 7
        python_hack: def __eq__(self, other): return self.value == other.value

    # ----------------------------------------------------------------------
    # |
    # |  Public Methods
    # |
    # ----------------------------------------------------------------------
    public static NormalizedIterator Create(NormalizedContent val content):
        return NormalizedIterator(
            NormalizedContentEx.Create(content),
            0,
            0,
            None,
            None,
        )

    # ----------------------------------------------------------------------
    public immutable String val __Repr?__():
        # TODO: return `[{self.Line}, {self.Column}] ({self.Offset})`
        return "[{}, {}] ({})".Format?(self.Line, self.Column, self.Offset)

    # ----------------------------------------------------------------------
    # TODO: Convert to properties

    public immutable String val ContentProper():
        return self._content.content

    public immutable PosInt val ContentLengthProper():
        return self._content.content_length

    public immutable LineInfos val LineInfosProper():
        return self._content.line_infos

    public immutable HashBytes val HashProper():
        return self._content.hash

    public immutable Bool val HasEndOfFileDedentsProper():
        return self._content.has_end_of_file_dedents

    public immutable UIntArch val OffsetProper():
        return self._offset

    public immutable LineInfo val LineInfoProper():
        return self._content.line_infos[self._line_info_index]

    public immutable PosInt val LineProper():
        return self._line_info_index + 1

    public immutable PosInt val ColumnProper():
        if self.AtEnd():
            return 1

        # TODO: return self._offset - self.LineInfo().offset_start + 1
        return self._offset - self.LineInfo.offset_start + 1

    python_hack: @property
    python_hack: def Content(self):
    python_hack:     return self.ContentProper()
    python_hack: @property
    python_hack: def ContentLength(self):
    python_hack:     return self.ContentLengthProper()
    python_hack: @property
    python_hack: def LineInfos(self):
    python_hack:     return self.LineInfosProper()
    python_hack: @property
    python_hack: def Hash(self):
    python_hack:     return self.HashProper()
    python_hack: @property
    python_hack: def HasEndOfFileDedents(self):
    python_hack:     return self.HasEndOfFileDedentsProper()
    python_hack: @property
    python_hack: def Offset(self):
    python_hack:     return self.OffsetProper()
    python_hack: @property
    python_hack: def LineInfo(self):
    python_hack:     return self.LineInfoProper()
    python_hack: @property
    python_hack: def Line(self):
    python_hack:     return self.LineProper()
    python_hack: @property
    python_hack: def Column(self):
    python_hack:     return self.ColumnProper()

    # ----------------------------------------------------------------------
    public immutable (
        HashBytes,
        UIntArch,
        (UIntArch | None),
        (UIntArch | None),
    ) ToCacheKey():
        return (
            self.Hash(),
            # TODO: self.Offset(),
            self.Offset,
            self._consumed_dedent_line.Clone(),
            self._consumed_dedent_count.Clone(),
        )

    # ----------------------------------------------------------------------
    public immutable Bool val AtEnd():
        # TODO: val line_infos = self.LineInfos()
        val line_infos = self.LineInfos

        if self._line_info_index == len(line_infos):
            return True

        if (
            # TODO: self.HasEndOfFileDedents()
            self.HasEndOfFileDedents
            and self._line_info_index == len(line_infos) - 1
            and self._consumed_dedent_line == self._line_info_index
            # TODO: and self._consumed_dedent_count == self.LineInfo().num_dedents
            and self._consumed_dedent_count == self.LineInfo.num_dedents
        ):
            return True

        return False

    # ----------------------------------------------------------------------
    public immutable TokenType val GetNextTokenType():
        if self.AtEnd():
            return TokenType.EndOfFile

        # TODO: val line_info = self.LineInfo()
        val line_info = self.LineInfo

        if (
            line_info.num_dedents is not None
            and (
                self._consumed_dedent_line != self._line_info_index
                or self._consumed_dedent_count != line_info.num_dedents
            )
        ):
            return TokenType.Dedent

        if self._offset < line_info.content_start:
            if line_info.new_indentation_value is not None:
                return TokenType.Indent

            return TokenType.WhitespacePrefix

        if self._offset < line_info.content_end:
            return TokenType.Content

        if self._offset >= line_info.content_end and self._offset < line_info.offset_end:
            return TokenType.WhitespaceSuffix

        assert self._offset == line_info.offset_end
        return TokenType.EndOfLine

    # ----------------------------------------------------------------------
    public immutable Bool val IsBlankLine():
        # We don't have a line when we are at the end, so it can't be a blank line by definition.
        if self.AtEnd():
            return False

        # The trailing dedent lines should not be considered blank lines
        if (
            # TODO: self._line_info_index == len(self.LineInfos()) - 1
            self._line_info_index == len(self.LineInfos) - 1
            # TODO: and self.HasEndOfFileDedents()
            and self.HasEndOfFileDedents
        ):
            return False

        # TODO: val line_info = self.LineInfo()
        val line_info = self.LineInfo
        return line_info.content_end == line_info.content_start

    # ----------------------------------------------------------------------
    public mutable None ConsumeDedent():
        # TODO: assert self.LineInfo().num_dedents is not None
        assert self.LineInfo.num_dedents is not None
        # TODO: assert self.Offset() == self.LineInfo().offset_start
        assert self.Offset == self.LineInfo.offset_start

        if self._consumed_dedent_line != self._line_info_index:
            self._consumed_dedent_line = self._line_info_index # TODO
            self._consumed_dedent_count = 0 # TODO

        # TODO: assert self._consumed_dedent_count is Int
        self._consumed_dedent_count += 1

    # ----------------------------------------------------------------------
    public mutable None SkipLine():
        self._offset = self.LineInfo.offset_end

        self.Advance(1)

    # ----------------------------------------------------------------------
    public mutable None SkipWhitespacePrefix():
        val offset = self._offset
        # TODO: val line_info = self.LineInfo()
        val line_info = self.LineInfo

        assert offset == line_info.offset_start

        val delta = line_info.content_start - offset

        if delta != 0:
            self.Advance(delta)

    # ----------------------------------------------------------------------
    public mutable None SkipWhitespaceSuffix():
        val offset = self._offset
        # TODO: val line_info = self.LineInfo()
        val line_info = self.LineInfo

        assert offset == line_info.content_end

        val delta = line_info.offset_end - offset

        if delta != 0:
            self.Advance(delta)

    # ----------------------------------------------------------------------
    public mutable None Advance(PosIntArch val delta):
        <<<
        Advances the offset within a line or moves to a new line if delta == 1.
        >>>

        val offset = self._offset
        # TODO: val line_info = self.LineInfo()
        val line_info = self.LineInfo

        if offset == line_info.offset_end:
            assert delta == 1
            assert self.GetNextTokenType() == TokenType.EndOfLine

            self._line_info_index += 1

        else:
            assert offset >= line_info.offset_start and offset <= line_info.offset_end, "The offset should be within the current line"
            assert offset + delta <= line_info.offset_end, "The delta should not move us past the current line"
            assert (
                offset >= line_info.content_start                                       # (A)
                or (
                    offset == line_info.offset_start
                    and (
                        offset + delta == line_info.content_start                       # (B)
                        or delta == line_info.offset_end - line_info.offset_start       # (C)
                    )
                )
            ), "We are looking at content (A), at the beginning of the line and are skipping the whitespace prefix (B) or are skipping the entire line (C)"

        self._offset += delta

    # ----------------------------------------------------------------------
    # |
    # |  Private Types
    # |
    # ----------------------------------------------------------------------
    [PrivateCtor]
    private immutable class NormalizedContentEx:
        public using LineInfos              = List<LineInfo>{min_length'=1}
        public using HashBytes              = List<Int8>{min_length'=32, max_length'=32}

        # ----------------------------------------------------------------------
        public String val content
        public PosInt val content_length
        public LineInfos val line_infos
        public HashBytes val hash
        [NoInit] public Bool val has_end_of_file_dedents

        python_hack: def Clone(self):
        python_hack:     return self.__class__(self.content, self.content_length, self.line_infos, self.hash)

        # ----------------------------------------------------------------------
        public static NormalizedContentEx Create(
            NormalizedContent val content,
        ):
            # TODO: In the future -- hash = (
            # TODO: In the future --     HashLib::Sha256()
            # TODO: In the future --         ->Update(content)
            # TODO: In the future --         ->Digest()
            # TODO: In the future -- )
            var hasher = HashLib::Sha256()
            hasher.Update(content.content)
            val hash = hasher.Digest()

            return NormalizedContentEx(
                content.content,
                content.content_length,
                content.line_infos,
                content.hash,
            )

        # ----------------------------------------------------------------------
        private override None __Init?__():
            val last_line_info = self.line_infos[-1]

            self.has_end_of_file_dedents = (
                last_line_info.num_dedents is not None
                and last_line_info.num_dedents > 0
                and last_line_info.offset_start == last_line_info.offset_end
                and last_line_info.content_start == last_line_info.offset_start
                and last_line_info.content_end == last_line_info.offset_end
            )

        python_hack: @property
        python_hack: def Content(self): return self.content
        python_hack: @property
        python_hack: def ContentLen(self): return self.content_length
        python_hack: @property
        python_hack: def LineInfos(self): return self.line_infos
        python_hack: @property
        python_hack: def Hash(self): return self.hash

    # TODO: Restore this code once inheritance is working as expected and remove the code above
    # private immutable class NormalizedContentEx
    #     extends NormalizedContent
    # :
    #     <<<
    #     Adds end-of-file-dedent info to NormalizedContent
    #     >>>
    #
    #     [NoInit] public Bool val has_end_of_file_dedents
    #
    #     # ----------------------------------------------------------------------
    #     private None __Init?__():
    #         val last_line_info = self.line_infos[-1]
    #
    #         self.has_end_of_file_dedents = ( # TODO
    #             last_line_info.num_dedents is not None
    #             and last_line_info.num_dedents > 0
    #             and last_line_info.offset_start == last_line_info.offset_end
    #             and last_line_info.content_start == last_line_info.offset_start
    #             and last_line_info.content_end == last_line_info.offset_end
    #         )

    python_hack: def Clone(self):
    python_hack:     return self.__class__(self._content, self._offset, self._line_info_index, self._consumed_dedent_line, self._consumed_dedent_count)

    # ----------------------------------------------------------------------
    # |
    # |  Private Data
    # |
    # ----------------------------------------------------------------------
    private NormalizedContentEx val _content

    private UIntArch var _offset
    private UIntArch var _line_info_index

    private (UIntArch | None) var _consumed_dedent_line
    private (UIntArch | None) var _consumed_dedent_count


# TODO: Remove this
python_hack: NormalizedContentEx = NormalizedIterator.NormalizedContentEx
python_hack: TokenType = NormalizedIterator.TokenType
