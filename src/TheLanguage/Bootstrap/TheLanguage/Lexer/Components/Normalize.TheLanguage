# ----------------------------------------------------------------------
# |
# |  Normalize.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-10-25 14:42:54
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
Contains types and functions used to normalize source content prior to lexing. This code works very
hard to remain agnostic to the syntax/grammar that ultimately relies on the normalized content.
>>>

# BugBug from HashLib import HashLib

from .. import Error

# BugBug: Need ability to use default bases visibility when creating ClassStatementDependencyParserInfo

# ----------------------------------------------------------------------
public immutable exception InvalidTabsAndSpacesError
    extends public Error # BugBug: Should not need last 'public'
:
    private override immutable String _GetMessageTemplate():
        return "The spaces and/or tabs used to indent this line differ from the spaces and/or table used on previous lines."


# ----------------------------------------------------------------------
public immutable exception NoClosingMultilineTokenError
    extends public Error # BugBug: Should not need last 'public'
:
    private override immutable String _GetMessageTemplate():
        return "A closing token was not found to match this multi-line opening token."


# ----------------------------------------------------------------------
protected immutable class LineInfo:
    # ----------------------------------------------------------------------
    public immutable class WhitespaceRange:
        public IntArch val begin
        public IntArch val end

        # ----------------------------------------------------------------------
        private override None __Init?__():
            assert self.begin < self.end

    # ----------------------------------------------------------------------

    public using WhitespaceRanges           = List<WhitespaceRange>{ min_length'=0 }

    # ----------------------------------------------------------------------
    public IntArch val offset_start
    public IntArch val offset_end
    public IntArch val content_start
    public IntArch val content_end

    public WhitespaceRanges val whitespace_ranges

    public (PosInt | None) val num_dedents
    public (PosInt | None) val new_indentation_value

    # ----------------------------------------------------------------------
    public immutable Bool HasWhitespacePrefix():
        return self.content_start != self.offset_start

    # ----------------------------------------------------------------------
    public immutable Bool HasContent():
        return self.content_start != self.content_end

    # ----------------------------------------------------------------------
    public immutable Bool HasWhitespaceSuffix():
        return self.content_end != self.offset_end

    # ----------------------------------------------------------------------
    private override None __Init?__():
        assert self.offset_end >= self.offset_start
        assert self.content_start >= self.offset_start
        assert self.content_end >= self.content_start
        assert self.content_end <= self.offset_end


# ----------------------------------------------------------------------
public immutable class NormalizedContent:
    public using LineInfos                  = List<LineInfo>{min_length'=1}
    public using HashBytes                  = List<Int8>{min_length'=32, max_length'=32}

    # ----------------------------------------------------------------------
    public String val content
    public PosInt val content_length
    public LineInfos val line_infos
    public HashBytes val hash

    # ----------------------------------------------------------------------
    public static NormalizedContent Create(
        String val content,
        PosInt val content_length,
        LineInfos val line_infos,
    ):
        # TODO: In the future -- hash = (
        # TODO: In the future --     HashLib::Sha256()
        # TODO: In the future --         ->Update(content)
        # TODO: In the future --         ->Digest()
        # TODO: In the future -- )

        hasher = HashLib::Sha256()
        hasher.Update(content)
        hash = hasher.Digest()

        return NormalizedContent(content, content_length, line_infos, hash)


# ----------------------------------------------------------------------
public NormalizedContent Normalize?(
    String var content,

    # BugBug: Describe
    (Set<String>{empty'=False} | None) var multiline_tokens_to_ignore=None,

    # BugBug: Describe
    (
        (
            Bool (                          # Return True to suppress indentation for the line, False to allow it
                IntArch,                    #   offset_start
                IntArch,                    #   offset_end
                IntArch,                    #   content_start
                IntArch,                    #   content_end
            )
        )
        | None
    ) var suppress_indentation_func=None,
):
    <<<
    Normalizes the provided content by organizing it into lines that have knowledge of their indentation
    relative to the lines around them.
    >>>

    # BugBug: This comment is very python-y

    # This code is intended to be a general purpose normalization algorithm, with no special
    # knowledge of underling grammars. In most cases, it is fairly straight forward to maintain
    # this architectural distinction. However, multi-line phrases present a problem.
    #
    # We track indentation change for each line, but multi-line phrases are special in that
    # any indentation changes that happen within that phrase should not impact the subsequent
    # phrases.
    #
    # Consider this python content:
    #
    #                                         Indentation Level   Indentation Stack
    #                                         -----------------   -----------------
    #     if True:                          #         0           [0]
    #         print(                        #         4           [0, 4]
    #             textwrap.dedent(          #         8           [0, 4, 8]
    #                 """\                  #        12           [0, 4, 8, 12]
    #                 Proper indentation.   #        12           [0, 4, 8, 12]
    #               Wonky indentation.      #        10           [0, 4, 8, 10]
    #                 Normal indentation.   #        12           [0, 4, 8, 10, 12]
    #                 """,                  #        12           [0, 4, 8, 10, 12]
    #             ),                        #         8           [0, 4, 8]             !!! Note that 2 dedents were introduced, rather than the 1 that was expected
    #         )                             #         4           [0, 4]
    #                                       #         0           [0]
    #
    # Since indents and dedents are meaningful, this presents a problem. To work around this, we
    # introduce the opt-in concept that (some/most?) multi-line phrases should not make changes
    # to the indentation stack. With this in place, the example above becomes:
    #
    #                                         Indentation Level   Indentation Stack
    #                                         -----------------   -----------------
    #     if True:                          #         0           [0]
    #         print(                        #         4           [0, 4]
    #             textwrap.dedent(          #         8           [0, 4, 8]
    #                 """\                  #        12           [0, 4, 8, 12]
    #                 Proper indentation.   #        12           ????
    #               Wonky indentation.      #        10           ????
    #                 Normal indentation.   #        12           ????
    #                 """,                  #        12           [0, 4, 8, 12]
    #             ),                        #         8           [0, 4, 8]             !!! Note that the indentation stack is the same existing the multi-line phrase as it was entering it
    #         )                             #         4           [0, 4]
    #                                       #         0           [0]
    #
    # However, this presents a new challenge - how do we recognize multi-line phrases without
    # any knowledge of the underlying grammar? We could hard-code knowledge of python
    # triple-quoted-strings, but that is not sufficient to support the dynamic generation of new
    # phrases at runtime.
    #
    # Therefore, this compromise has been implemented. The presence of a line with one or more
    # triplets represents the beginning and end of a multi-line phrase. Indentation tracking will
    # pause when one of these lines is found and resume when another is encountered. Examples of
    # these triples are:
    #
    #       Enter Multiline Phrase  Exit Multiline Phrase
    #       ----------------------  ---------------------
    #                """                    """
    #                <<<                    >>>         !!! Note that the enter and exit triplets do not have to be the same
    #               <<<!!!                !!!>>>        !!! Note that there can be multiple triplets as part of a phrase
    #

    content = (content if content[-1] == '\n' else (content + '\n')) as val
    multiline_tokens_to_ignore = (multiline_tokens_to_ignore or Set<String>()) as val

    # TODO: The parameter names in the lambda should not be required long term. Need to improve how types, parameters, and arguments interact
    suppress_indentation_func = (suppress_indentation_func or (
        lambda (
            IntArch offset_start,
            IntArch offset_end,
            IntArch content_start,
            IntArch content_end
        ):
            False
    )) as val # TODO: lambda ***: False

    content_length = content.Length()

    # ----------------------------------------------------------------------
    immutable class IndentationInfo:
        IntArch val num_chars
        UInt val value

    # ----------------------------------------------------------------------
    immutable class MultilineTokenInfo:
        public IntArch val line_index
        public PosInt val num_delimiters

    # ----------------------------------------------------------------------

    var line_infos = List<LineInfo>()
    var indentation_stack = Stack<IndentationInfo>()
    var multiline_token_info = None as (MultilineTokenInfo | None)

    var offset = 0 as IntArch

    # ----------------------------------------------------------------------
    LineInfo CreateLineInfo
        |offset, indentation_stack|
    ():
        offset_start = offset

        # Capture whitespace regions within the line
        val whitespace_ranges = List<WhitespaceRange>() # TODO: LineInfo::WhitespaceRanges()
        var whitespace_start = None as (TypeOf'(offset) | None)

        while True:
            val char = content[offset]

            if char == ' ' or char == '\t':
                if whitespace_start is None:
                    whitespace_start = offset

            else:
                if whitespace_start is not None:
                    whitespace_ranges.InsertBack?(LineInfo.WhitespaceRange(whitespace_start, offset))
                    whitespace_start = None

                if char == '\n':
                    break

            offset += 1

        val offset_end = offset

        # Calculate the beginning and end of the content (taking into account leading and trailing
        # whitespace)
        TypeOf'(offset) once content_start
        TypeOf'(offset) once content_end

        if not whitespace_ranges:
            content_start = offset
            content_end = offset
        else:
            with initial_range = whitespace_ranges.TryPeek(0):
                content_start = initial_range.end if initial_range and initial_range.begin == offset_start else offset_start

            with last_range = whitespace_ranges.TryPeek(-1):
                content_end = last_range.begin if last_range and last_range.end == offset_end else offset_end

        # Calculate new dedentation- and indentation-values
        (UInt | None) once num_dedents
        (UInt | None) once new_indentation_value

        if multiline_token_info is not None or suppress_indentation_func(
            offset_start,
            offset_end,
            content_start,
            content_end,
        ):
            num_dedents = None
            new_indentation_value = None

        else:
            # Does the detected indentation for this line represent a dedent and/or indent?
            val this_num_chars = content_start - offset_start
            var this_indentation_value = 0

            if this_num_chars != 0:
                for index in IntGenerator(offset_start, content_start):
                    char = content[index]

                    # Ensure that " \t" compares as different from "\t " and that "\t" compares
                    # as different from " ".
                    if char == ' ':
                        this_indentation_value += 1
                    elif char == '\t':
                        this_indentation_value += (index - offset_start + 1) * 100
                    else:
                        assert False, char

            # Ensure that the whitespace prefix for this line uses the same configuration of tabs and
            # spaces as the indentation associated with the previous line if the number of characters
            # are the same.
            if (
                this_num_chars == indentation_stack.Peek().num_chars
                and this_indentation_value != indentation_stack.Peek().value
            ):
                raise InvalidTabsAndSpacesError(
                    line_infos.Length() + 1,
                    content_start - offset_start + 1,
                )

            num_dedents = 0

            # Detect dedents
            while this_num_chars < indentation_stack.Peek().num_chars:
                indentation_stack.Pop?()
                num_dedents += 1

            # Detect indents
            if this_num_chars > indentation_stack.Peek().num_chars:
                new_indentation_value = this_indentation_value
                indentation_stack.Push?(IndentationInfo(this_num_chars, this_indentation_value))

        return LineInfo(
            offset_start,
            offset_end,
            content_start,
            content_end,
            move whitespace_ranges,
            move num_dedents,
            move new_indentation_value,
        )

        # BugBug view offset_start = offset
        # BugBug
        # BugBug once view offset_end = None as TypeOf'(offset)
        # BugBug once view content_start = None as TypeOf'(offset)
        # BugBug once view content_end = None as TypeOf'(offset)
        # BugBug
        # BugBug var calculated_indentation_value = 0 as (Int | None)
        # BugBug var num_pending_dedentations = 0
        # BugBug var pending_indentation = None as (IndentationInfo | None)
        # BugBug
        # BugBug while offset < content_length:
        # BugBug     char = content[offset]
        # BugBug
        # BugBug     if calculated_indentation_value is not None:
        # BugBug         if char == ' ':
        # BugBug             calculated_indentation_value += 1
        # BugBug
        # BugBug         elif char == '\t':
        # BugBug             # Ensure that " \t" compares as different from "\t " and that "\t" compares
        # BugBug             # as different from " ".
        # BugBug             calculated_indentation_value += (offset - offset_start + 1) * 100
        # BugBug
        # BugBug         else:
        # BugBug             assert char == '\n' or not char.IsSpace(), char
        # BugBug
        # BugBug             num_chars = offset - offset_start
        # BugBug
        # BugBug             if char == '\n':
        # BugBug                 # Ensure that the whitespace prefix for this line uses the same number of
        # BugBug                 # tabs and spaces as the indentation associated with the previous line.
        # BugBug                 if (
        # BugBug                     num_chars == indentation_stack[-1].num_chars
        # BugBug                     and calculated_indentation_value != indentation_stack[-1].value
        # BugBug                 ):
        # BugBug                     raise InvalidTabsAndSpacesError(
        # BugBug                         line_infos.Length() + 1,
        # BugBug                         offset - offset_start + 1,
        # BugBug                     )
        # BugBug
        # BugBug                 if multiline_token_info is None:
        # BugBug                     # Detect dedents
        # BugBug                     while num_chars < indentation_stack[-1 + -num_pending_dedentations].num_chars:
        # BugBug                         num_pending_dedentations += 1
        # BugBug
        # BugBug                     num_pending_dedentations = final num_pending_dedentations
        # BugBug
        # BugBug                     # Detect indents
        # BugBug                     if num_chars > indentation_stack[-1 + -num_pending_dedentations].num_chars:
        # BugBug                         pending_indentation = IndentationInfo(num_chars, calculated_indentation_value)
        # BugBug
        # BugBug             calculated_indentation_value = final None
        # BugBug             content_start = final offset
        # BugBug
        # BugBug     elif char == '\n':
        # BugBug         offset_end = final offset
        # BugBug         offset += 1
        # BugBug
        # BugBug         # Detect trailing whitespace
        # BugBug
        # BugBug         content_end = offset_end
        # BugBug
        # BugBug         assert content_start is not None
        # BugBug         while content_end > content_start and content[content_end - 1].IsSpace():
        # BugBug             content_end -= 1
        # BugBug
        # BugBug     offset += 1
        # BugBug
        # BugBug assert offset_end is not None
        # BugBug assert content_start is not None
        # BugBug assert content_end is not None
        # BugBug
        # BugBug var has_indentation = pending_indentation is not None
        # BugBug
        # BugBug if (
        # BugBug     (num_pending_dedentations or has_indentation)
        # BugBug     and (
        # BugBug         multiline_token_info is not None
        # BugBug         or suppress_indentation_func(
        # BugBug             offset_start,
        # BugBug             offset_end,
        # BugBug             content_start,
        # BugBug             content_end,
        # BugBug         )
        # BugBug     )
        # BugBug ):
        # BugBug     num_pending_dedentations = 0
        # BugBug     has_indentation = False
        # BugBug
        # BugBug else:
        # BugBug     if pending_indentation is not None:
        # BugBug         indentation_stack.append(move pending_indentation)
        # BugBug
        # BugBug return LineInfo(
        # BugBug     offset_start,
        # BugBug     offset_end,
        # BugBug     content_start,
        # BugBug     content_end,
        # BugBug     num_dedents=num_pending_dedentations or None,
        # BugBug     new_indentation_value=indentation_stack[-1].value if has_indentation else None,
        # BugBug )

    # ----------------------------------------------------------------------

    while offset < content_length:
        line_infos.Append(CreateLineInfo())

        num_multiline_delimiters = GetNumMultilineTokenDelimiters(
            content,
            start_index=line_infos[-1].content_start,
            end_index=line_infos[-1].content_end,
        )

        if (
            num_multiline_delimiters != 0
            and content[line_infos[-1].content_start..line_infos[-1].content_end] not in multiline_tokens_to_ignore # BugBug: '..' binary expression
        ):
            # Toggle the current state
            if multiline_token_info is None:
                multiline_token_info = MultilineTokenInfo(line_infos.Length() - 1, num_multiline_delimiters)
            else:
                multiline_token_info = None

    # Detect when a mutliline token has been opened but not closed
    if multiline_token_info is not None:
        line_info = line_infos[multiline_token_info.line_index]  # BugBug: Defaulting to other type when there is only 2

        raise NoClosingMultilineTokenError(
            multiline_token_info.line_index + 1,
            line_info.content_start - line_info.offset_start + 1,
        )

    # Add trailing dedents if necessary
    if indentation_stack.Length() > 1:
        line_infos.append(
            LineInfo(
                offset,
                offset,
                offset,
                offset,
                List<(IntArch, IntArch)>(),
                indentation_stack.Length() - 1,
                None,
            ),
        )

    return NormalizedContent.Create(move content, move content_length, move line_infos)


# ----------------------------------------------------------------------
# TODO: protected val multiline_token_delimiter_length = 3
val multiline_token_delimiter_length = 3

protected UInt GetNumMultilineTokenDelimiters(
    String val content,
    UIntArch val start_index,
    UIntArch val end_index,
):
    <<<
    Returns the number of valid multiline token delimiter items at the given position in the provided content.
    See the comments in `Normalize` for more information.
    >>>

    if start_index == end_index:
        return 0

    if (end_index - start_index) % multiline_token_delimiter_length != 0:
        return 0

    var index = start_index

    while index != end_index:
        # The character must be a symbol
        val char = content[index]

        if (
            (char >= 'A' and char <= 'Z')
            or (char >= 'a' and char <= 'z')
            or (char >= '0' and char <= '9')
        ):
            return 0

        # Every item within the delimiter must be the same
        for offset in IntGenerator(index + 1, index + multiline_token_delimiter_length):
            if content[offset] != char:
                return 0

        index += multiline_token_delimiter_length

    return (end_index - start_index) // multiline_token_delimiter_length
