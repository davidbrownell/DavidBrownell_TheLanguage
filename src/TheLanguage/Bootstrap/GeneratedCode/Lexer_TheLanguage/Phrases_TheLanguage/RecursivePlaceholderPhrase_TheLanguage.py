# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String

    from ..Components_TheLanguage.Phrase_TheLanguage import Phrase

# Visibility: public
# ClassModifier: mutable
# ClassType: Class
class RecursivePlaceholderPhrase(Phrase):
    """\
    Temporary phrase that should be replace before participating in lexing activites.

    Instances of this object are used as sentinels within a Phrase hierarchy to implement
    recursive grammars.
    """

    def __init__(self, *args, **kwargs):
        RecursivePlaceholderPhrase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # 

        Phrase._InternalInit(self, args, kwargs)

        # No members

        self._Init_7bddcdce43d4438891bbe073ad4292d6_()

    def __eq__(self, other):
        compare_cache = {}

        if Phrase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Phrase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Phrase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Phrase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Phrase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Phrase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Phrase.__Compare__(a, b, compare_cache)
        if result != 0: return result



        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_7bddcdce43d4438891bbe073ad4292d6_(self):
        pass

    # Return Type: RecursivePlaceholderPhrase
    @staticmethod
    def Create():
        return RecursivePlaceholderPhrase("Recursive", )

    # Return Type: <LexResult | None> val
    def Lex(self, unique_id, iter, observer, ignore_whitespace=False, ):
        raise Exception("This method should never be called on an instance of this object", )

    # Return Type: Bool val
    def _PopulateRecursiveImpl(self, new_phrase, ):
        raise Exception("This method should never be called on an instance of this object", )

