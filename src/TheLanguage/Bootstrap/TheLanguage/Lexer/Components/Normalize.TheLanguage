# ----------------------------------------------------------------------
# |
# |  Normalize.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-10-25 14:42:54
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
Contains types and functions used to normalize source content prior to lexing. This code works very
hard to remain agnostic to the syntax/grammar that ultimately relies on the normalized content.
>>>

# BugBug from HashLib import HashLib

from .. import Error

# BugBug: Need ability to use default bases visibility when creating ClassStatementDependencyParserInfo

# ----------------------------------------------------------------------
public immutable exception InvalidTabsAndSpacesError
    extends public Error # BugBug: Should not need last 'public'
:
    private override immutable String _GetMessageTemplate():
        return "The spaces and/or tabs used to indent this line differ from the spaces and/or table used on previous lines."


# ----------------------------------------------------------------------
public immutable exception NoClosingMultilineTokenError
    extends public Error # BugBug: Should not need last 'public'
:
    private override immutable String _GetMessageTemplate():
        return "A closing token was not found to match this multi-line opening token."


# ----------------------------------------------------------------------
protected immutable class LineInfo:
    # ----------------------------------------------------------------------
    public immutable class WhitespaceRange:
        public IntArch val begin
        public IntArch val end

        # ----------------------------------------------------------------------
        private override None __Init?__():
            ensure self.begin < self.end

    # ----------------------------------------------------------------------

    public using WhitespaceRanges           = List<WhitespaceRange>{ min_length'=0 }

    # ----------------------------------------------------------------------
    public IntArch val offset_start
    public IntArch val offset_end
    public IntArch val content_start
    public IntArch val content_end

    public WhitespaceRanges val whitespace_ranges

    public (PosInt | None) val num_dedents = None
    public (PosInt | None) val new_indentation_value = None

    # ----------------------------------------------------------------------
    public immutable Bool HasWhitespacePrefix():
        return self.content_start != self.offset_start

    # ----------------------------------------------------------------------
    public immutable Bool HasContent():
        return self.content_start != self.content_end

    # ----------------------------------------------------------------------
    public immutable Bool HasWhitespaceSuffix():
        return self.content_end != self.offset_end

    # ----------------------------------------------------------------------
    private override None __Init?__():
        ensure self.offset_end >= self.offset_start
        ensure self.content_start >= self.offset_start
        ensure self.content_end >= self.content_start
        ensure self.content_end <= self.offset_end

    python_hack: @property
    python_hack: def OffsetStart(self): return self.offset_start
    python_hack: @property
    python_hack: def OffsetEnd(self): return self.offset_end
    python_hack: @property
    python_hack: def ContentStart(self): return self.content_start
    python_hack: @property
    python_hack: def ContentEnd(self): return self.content_end
    python_hack: @property
    python_hack: def NumDedents(self): return self.num_dedents
    python_hack: @property
    python_hack: def NewIndentationValue(self): return self.new_indentation_value


# ----------------------------------------------------------------------
[ProtectedCtor]
public immutable class NormalizedContent:
    public using LineInfos                  = List<LineInfo>{min_length'=1}
    public using HashBytes                  = List<Int8>{min_length'=32, max_length'=32}

    # ----------------------------------------------------------------------
    public String val content
    public PosInt val content_length
    public LineInfos val line_infos
    public HashBytes val hash

    # ----------------------------------------------------------------------
    public static NormalizedContent Create(
        String val content,
        PosInt val content_length,
        LineInfos val line_infos,
    ):
        # TODO: In the future -- hash = (
        # TODO: In the future --     HashLib::Sha256()
        # TODO: In the future --         ->Update(content)
        # TODO: In the future --         ->Digest()
        # TODO: In the future -- )

        var hasher = HashLib::Sha256()
        hasher.Update(content)
        val hash = hasher.Digest()

        return NormalizedContent(content, content_length, line_infos, hash)

    python_hack: @property
    python_hack: def Content(self): return self.content
    python_hack: @property
    python_hack: def ContentLen(self): return self.content_length
    python_hack: @property
    python_hack: def ContentLength(self): return self.content_length
    python_hack: @property
    python_hack: def LineInfos(self): return self.line_infos
    python_hack: @property
    python_hack: def Hash(self): return self.hash


# ----------------------------------------------------------------------
public NormalizedContent Normalize?(
    String var content,

    # BugBug: Describe
    (Set<String>{empty'=False} | None) var multiline_tokens_to_ignore=None,

    # BugBug: Describe
    (
        (
            Bool (                          # Return True to suppress indentation for the line, False to allow it
                IntArch,                    #   offset_start
                IntArch,                    #   offset_end
                IntArch,                    #   content_start
                IntArch,                    #   content_end
            )
        )
        | None
    ) var suppress_indentation_func=None,
):
    <<<
    Normalizes the provided content by organizing it into lines that have knowledge of their indentation
    relative to the lines around them.
    >>>

    # BugBug: This comment is very python-y

    # This code is intended to be a general purpose normalization algorithm, with no special
    # knowledge of underling grammars. In most cases, it is fairly straight forward to maintain
    # this architectural distinction. However, multi-line phrases present a problem.
    #
    # We track indentation change for each line, but multi-line phrases are special in that
    # any indentation changes that happen within that phrase should not impact the subsequent
    # phrases.
    #
    # Consider this python content:
    #
    #                                         Indentation Level   Indentation Stack
    #                                         -----------------   -----------------
    #     if True:                          #         0           [0]
    #         print(                        #         4           [0, 4]
    #             textwrap.dedent(          #         8           [0, 4, 8]
    #                 """\                  #        12           [0, 4, 8, 12]
    #                 Proper indentation.   #        12           [0, 4, 8, 12]
    #               Wonky indentation.      #        10           [0, 4, 8, 10]
    #                 Normal indentation.   #        12           [0, 4, 8, 10, 12]
    #                 """,                  #        12           [0, 4, 8, 10, 12]
    #             ),                        #         8           [0, 4, 8]             !!! Note that 2 dedents were introduced, rather than the 1 that was expected
    #         )                             #         4           [0, 4]
    #                                       #         0           [0]
    #
    # Since indents and dedents are meaningful, this presents a problem. To work around this, we
    # introduce the opt-in concept that (some/most?) multi-line phrases should not make changes
    # to the indentation stack. With this in place, the example above becomes:
    #
    #                                         Indentation Level   Indentation Stack
    #                                         -----------------   -----------------
    #     if True:                          #         0           [0]
    #         print(                        #         4           [0, 4]
    #             textwrap.dedent(          #         8           [0, 4, 8]
    #                 """\                  #        12           [0, 4, 8, 12]
    #                 Proper indentation.   #        12           ????
    #               Wonky indentation.      #        10           ????
    #                 Normal indentation.   #        12           ????
    #                 """,                  #        12           [0, 4, 8, 12]
    #             ),                        #         8           [0, 4, 8]             !!! Note that the indentation stack is the same existing the multi-line phrase as it was entering it
    #         )                             #         4           [0, 4]
    #                                       #         0           [0]
    #
    # However, this presents a new challenge - how do we recognize multi-line phrases without
    # any knowledge of the underlying grammar? We could hard-code knowledge of python
    # triple-quoted-strings, but that is not sufficient to support the dynamic generation of new
    # phrases at runtime.
    #
    # Therefore, this compromise has been implemented. The presence of a line with one or more
    # triplets represents the beginning and end of a multi-line phrase. Indentation tracking will
    # pause when one of these lines is found and resume when another is encountered. Examples of
    # these triples are:
    #
    #       Enter Multiline Phrase  Exit Multiline Phrase
    #       ----------------------  ---------------------
    #                """                    """
    #                <<<                    >>>         !!! Note that the enter and exit triplets do not have to be the same
    #               <<<!!!                !!!>>>        !!! Note that there can be multiple triplets as part of a phrase
    #

    content = (content if content and content[-1] == '\n' else (content + '\n')) as val # TODO
    multiline_tokens_to_ignore = (multiline_tokens_to_ignore or Set<String>()) as val # TODO

    # TODO: The parameter names in the lambda should not be required long term. Need to improve how types, parameters, and arguments interact
    suppress_indentation_func = (suppress_indentation_func or ( # TODO
        lambda (
            IntArch offset_start,
            IntArch offset_end,
            IntArch content_start,
            IntArch content_end
        ):
            False
    )) as val # TODO: lambda ***: False

    content_length = content.Length() # TODO

    # ----------------------------------------------------------------------
    private immutable class IndentationInfo:
        public IntArch val num_chars
        public UInt val value

    # ----------------------------------------------------------------------
    private immutable class MultilineTokenInfo:
        public IntArch val line_index
        public PosInt val num_delimiters

    # ----------------------------------------------------------------------

    var line_infos = List<LineInfo>()
    var indentation_stack = Stack<IndentationInfo>::Create(IndentationInfo(0, 0))
    var multiline_token_info = None as (MultilineTokenInfo | None)

    var offset = 0 as IntArch

    # ----------------------------------------------------------------------
    LineInfo CreateLineInfo
        |offset, indentation_stack|
    ():
        val offset_start = offset

        # Capture whitespace regions within the line
        val whitespace_ranges = List<WhitespaceRange>() # TODO: LineInfo::WhitespaceRanges()
        var whitespace_start = None as (TypeOf'(offset) | None)

        while True:
            val char = content[offset]

            if char == ' ' or char == '\t': # TODO: char.IsHorizontalWhitespace()
                if whitespace_start is None:
                    whitespace_start = offset # TODO

            else:
                if whitespace_start is not None:
                    whitespace_ranges.InsertBack?(
                        LineInfo.WhitespaceRange(copy whitespace_start, copy offset)
                    )

                    whitespace_start = None # TODO

                if char == '\n':
                    break

            offset += 1

        val offset_end = offset

        # Calculate the beginning and end of the content (taking into account leading and trailing
        # whitespace)
        TypeOf'(offset) once content_start
        TypeOf'(offset) once content_end

        if not whitespace_ranges:
            content_start = offset_start # TODO
            content_end = offset_end # TODO
        else:
            with initial_range = whitespace_ranges.Peek?(0):
                if initial_range.begin == offset_start:
                    content_start = initial_range.end # TODO
                else:
                    content_start = offset_start # TODO

            with last_range = whitespace_ranges.Peek?(-1):
                if last_range.end == offset_end and last_range.begin != offset_start:
                    content_end = last_range.begin # TODO
                else:
                    content_end = offset_end # TODO

        # Calculate new dedentation- and indentation-values
        (UInt | None) once num_dedents
        (UInt | None) once new_indentation_value

        if (
            content_start == content_end
            or multiline_token_info is not None
            or suppress_indentation_func(
                offset_start,
                offset_end,
                content_start,
                content_end,
            )
        ):
            num_dedents = None # TODO
            new_indentation_value = None # TODO

        else:
            # Does the detected indentation for this line represent a dedent and/or indent?
            val this_num_chars = content_start - offset_start
            var this_indentation_value = 0

            if this_num_chars != 0:
                for index in IntGenerator(offset_start, content_start):
                    char = content[index] # TODO

                    # Ensure that " \t" compares as different from "\t " and that "\t" compares
                    # as different from " ".
                    if char == ' ':
                        this_indentation_value += 1
                    elif char == '\t':
                        this_indentation_value += (index - offset_start + 1) * 100
                    else:
                        assert False, char

            # Ensure that the whitespace prefix for this line uses the same configuration of tabs and
            # spaces as the indentation associated with the previous line if the number of characters
            # are the same.
            if (
                this_num_chars == indentation_stack.Peek().num_chars
                and this_indentation_value != indentation_stack.Peek().value
            ):
                raise InvalidTabsAndSpacesError(
                    line_infos.Length() + 1,
                    content_start - offset_start + 1,
                )

            num_dedents = 0 # TODO

            # Detect dedents
            while this_num_chars < indentation_stack.Peek().num_chars:
                indentation_stack.Pop?()
                num_dedents += 1

            if num_dedents == 0:
                num_dedents = None # TODO

            # Detect indents
            if this_num_chars > indentation_stack.Peek().num_chars:
                new_indentation_value = this_indentation_value # TODO
                indentation_stack.Push?(IndentationInfo(this_num_chars, this_indentation_value))
            else:
                new_indentation_value = None # TODO

        offset += 1

        return LineInfo(
            offset_start,
            offset_end,
            content_start,
            content_end,
            move whitespace_ranges,
            move num_dedents,
            move new_indentation_value,
        )

    # ----------------------------------------------------------------------

    while offset < content_length:
        line_infos.Append?(CreateLineInfo())

        num_multiline_delimiters = GetNumMultilineTokenDelimiters( # TODO
            content,
            start_index=line_infos[-1].content_start,
            end_index=line_infos[-1].content_end,
        )

        if (
            num_multiline_delimiters != 0
            and content[line_infos[-1].content_start..line_infos[-1].content_end] not in multiline_tokens_to_ignore
        ):
            # Toggle the current state
            if multiline_token_info is None:
                multiline_token_info = MultilineTokenInfo(line_infos.Length() - 1, num_multiline_delimiters) # TODO
            else:
                multiline_token_info = None # TODO

    # Detect when a mutliline token has been opened but not closed
    if multiline_token_info is not None:
        line_info = line_infos[multiline_token_info.line_index]  # BugBug: Defaulting to other type when there is only 2 # TODO

        raise NoClosingMultilineTokenError(
            multiline_token_info.line_index + 1,
            line_info.content_start - line_info.offset_start + 1,
        )

    # Add trailing dedents if necessary
    if indentation_stack.Length() > 1:
        line_infos.append(
            LineInfo(
                offset,
                offset,
                offset,
                offset,
                List<(IntArch, IntArch)>(),
                indentation_stack.Length() - 1,
                None,
            ),
        )

    return NormalizedContent.Create(move content, move content_length, move line_infos)


# ----------------------------------------------------------------------
# TODO: protected val multiline_token_delimiter_length = 3
val multiline_token_delimiter_length = 3

python_hack: import textwrap
python_hack: MultilineTokenDelimiterRegexTemplate        = textwrap.dedent(
python_hack:     r"""{{header}}(?#
python_hack:         Don't consume other triplets.
python_hack:             The number of items here must match
python_hack:             MULTILINE_TOKEN_DELIMITER_ITEM_LENGTH.           )(?!{triplet_item}{triplet_item}{triplet_item})(?#
python_hack:         Value                                           )(?P<value>.*?)(?#
python_hack:         No slash as a prefix to the closing triplet[s]  )(?<!\\)(?#
python_hack:     ){{footer}}""",
python_hack: ).format(
python_hack:     triplet_item=r"[^A-Za-z0-9 \t\n]",
python_hack: )

protected UInt GetNumMultilineTokenDelimiters(
    String val content,
    UIntArch val start_index,
    UIntArch val end_index,
):
    <<<
    Returns the number of valid multiline token delimiter items at the given position in the provided content.
    See the comments in `Normalize` for more information.
    >>>

    if start_index == end_index:
        return 0

    if (end_index - start_index) % multiline_token_delimiter_length != 0:
        return 0

    var index = start_index

    while index != end_index:
        # The character must be a symbol
        val char = content[index]

        if (
            (char >= 'A' and char <= 'Z')
            or (char >= 'a' and char <= 'z')
            or (char >= '0' and char <= '9')
            or char == '_'
        ):
            return 0

        # Every item within the delimiter must be the same
        for offset in IntGenerator(index + 1, index + multiline_token_delimiter_length):
            if content[offset] != char:
                return 0

        index += multiline_token_delimiter_length

    return (end_index - start_index) // multiline_token_delimiter_length
