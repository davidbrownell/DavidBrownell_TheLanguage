# ----------------------------------------------------------------------
# |
# |  DynamicPhrase.TheLanguage
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-12-24 11:21:24
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
<<<
Contains the `DynamicPhrase` object.
>>>

from .OrPhrase import OrPhrase
from .RecursivePlaceholderPhrase import RecursivePlaceholderPhrase
from .SequencePhrase import SequencePhrase
from .TokenPhrase import TokenPhrase

from ..Components.Phrase import DynamicPhrasesType, Phrase, UniqueId

python_hack: import uuid

# ----------------------------------------------------------------------
[PrivateCtor]
public mutable class DynamicPhrase
    extends Phrase
:
    <<<
    Collects dynamic phrases and invokes them, ensuring that left- and right-recursive phrases work
    as intended.

    Prevents infinte recursion for those phrases that are left-recursive (meaning they belong to
    a category and consume that same category as the first phrase within the sequence).

    Examples of left-recursive phrases:
        AddExpression := <expression> '+' <expression>
        CastExpression := <expression> 'as' <type>
        IndexExpression := <expression> '[' <expression> ']'

    Examples of right-recursive phrases:
        AddExpression := <expression> '+' <expression>
        NegativeExpression := '-' <expression>
    >>>

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # |
    # |  Types
    # |
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    public using Phrases = List<Phrase>{ min_length'=1 }

    public using GetDynamicPhrasesFunc = (
        # Return Type
        (
            String,
            Phrases,
        )

        # Arguments
        (
            UniqueId immutable,
            DynamicPhrasesType immutable,
            Oberver ref,
        )
    )

    public using IsValidDataFunc = (
        # Return Type
        Bool val

        # Arguments
        (
            PhraseLexResultData immutable,
        )
    )

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # |
    # |  Data
    # |
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    public DynamicPhrasesType val phrases_type
    [NoCompare, NoSerialize] public IsValidDataFunc val is_valid_data_func

    [NoCompare, NoSerialize] private GetDynamicPhrasesFunc val _get_dynamic_phrases_func
    [NoInit, NoCompare, NoSerialize, Mutable] private (_Lexer | None) var _lexer = None

    # TODO: 'display_name' property

    python_hack: @property
    python_hack: def DisplayName(self): return None if self._lexer is None else self._lexer.display_name
    python_hack: def __hash__(self): return super(DynamicPhrase, self).__hash__()

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # |
    # |  Public Methods
    # |
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # TODO: Add 'ThisClass' as a type and use as the return value
    public static DynamicPhrase Create(
        any:
            DynamicPhrasesType val phrases_type,
            GetDynamicPhrasesFunc val get_dynamic_phrases_func,
        key:
            (List<(Phrase | String)>{ min_length'=1} | None) immutable include_phrases=None,
            (List<(Phrase | String)>{ min_length'=1} | None) immutable exclude_phrases=None,
            (IsValidDataFunc | None) var is_valid_data_func=None,
            (String | None) var name=None,
    ):
        # BugBug: Include and exclude phrases?

        # TODO: '***'
        # TODO: is_valid_data_func = is_valid_data_func or lambda (PhraseLexResultData immutable data): True

        # TODO: Remove (begin)
        private Bool val _DefaultIsValidDataFunc(PhraseLexResultData immutable data):
            return True

        is_valid_data_func = is_valid_data_func or _DefaultIsValidDataFunc
        # TODO: Remove (end)

        name = name or "Dynamic Phrase"

        return DynamicPhrase(
            move name,
            phrases_type,
            move is_valid_data_func,
            get_dynamic_phrases_func,
        )

    # ----------------------------------------------------------------------
    public override immutable (LexResult | None) val Lex(
        any:
            UniqueId val unique_id,
            NormalizedIterator var iter,
            Observer ref observer,
        key:
            Bool val ignore_whitespace = False,
    ):
        var result = None as (LexResult | None)

        observer.StartPhrase(unique_id, self)
        # TODO: exit: observer.EndPhrase(unique_id, self, result is not None and result.success)

        # TODO: val (dynamic_phrases_name, dynamic_phrases, ) = self._get_dynamic_phrases_func(
        # TODO:     unique_id,
        # TODO:     self.phrases_type,
        # TODO:     # TODO: ref observer,
        # TODO:     observer,
        # TODO: )

        # BugBug (begin)
        val dynamic_info = self._get_dynamic_phrases_func(unique_id, self.phrases_type, observer)
        val dynamic_phrases_name = dynamic_info[1]
        val dynamic_phrases = dynamic_info[0]
        # BugBug (end)

        val dynamic_unique_id = 0 # TODO

        if True: # TODO self._lexer is None or dynamic_unique_id != self._lexer.unique_id:
            # Organize the phrases by those that are left-recursive and those that are not
            var left_recursive_phrases = List<Phrase>()
            var standard_phrases = List<Phrase>()

            for phrase in dynamic_phrases:
                # TODO: Use 'ThisClass'
                if DynamicPhrase.IsLeftRecursivePhrase(phrase, self.phrases_type):
                    left_recursive_phrases.InsertBack?(phrase)
                else:
                    standard_phrases.InsertBack?(phrase)

            python_hack: _LeftRecursiveLexer = DynamicPhrase._LeftRecursiveLexer
            python_hack: _StandardLexer = DynamicPhrase._StandardLexer

            if left_recursive_phrases:
                self._lexer = _LeftRecursiveLexer(
                    dynamic_unique_id,
                    dynamic_phrases_name,
                    move standard_phrases,
                    move left_recursive_phrases,
                )
            else:
                self._lexer = _StandardLexer(
                    dynamic_unique_id,
                    dynamic_phrases_name,
                    move standard_phrases,
                )

        assert self._lexer is not None

        result = self._lexer.Execute(
            self,
            unique_id,
            move iter,
            # TODO: ref observer
            observer,
            ignore_whitespace=ignore_whitespace,
        )

        if result is None:
            return None

        if (
            result.success
            and not observer.OnInternalPhraseProxy(result.data, result.range)
        ):
            return None

        return result

    # ----------------------------------------------------------------------
    public static Bool val IsLeftRecursivePhrase(
        Phrase immutable phrase,
        (DynamicPhrasesType | None) immutable phrases_type=None,
    ):
        python_hack: phrases_length = len(phrase.Phrases)

        return (
            phrase is SequencePhrase
            # TODO: and phrase.Phrases.Length() > 1
            and phrases_length > 1 # TODO (remove)
            and phrase.Phrases[0] is DynamicPhrase
            and (
                phrases_type is None
                or phrase.Phrases[0].phrases_type == phrases_type
            )
        )

    # ----------------------------------------------------------------------
    public static Bool val IsRightRecursivePhrase(
        Phrase immutable phrase,
        (DynamicPhrasesType | None) immutable phrases_type=None,
    ):
        python_hack: phrases_length = len(phrase.Phrases)

        return (
            phrase is SequencePhrase
            # TODO: and phrase.Phrases.Length() > 2
            and phrases_length > 2 # TODO (remove)
            and phrase.Phrases[-1] is DynamicPhrase
            and (
                phrases_type is None
                or phrase.Phrases[-1].phrases_type == phrases_type
            )
        )

    # ----------------------------------------------------------------------
    public static PhraseLexResultData val SkipDynamicData(PhraseLexResultData val data):
        <<<
        Skips the `LexResultData` that is associated with the implementation details of
        `DynamicPhrase` results.
        >>>

        assert data.phrase is DynamicPhrase
        assert data.data is PhraseLexResultData

        var data = data.data

        assert data.phrase is OrPhrase
        assert data.data is PhraseLexResultData

        data = data.data

        return data

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # |
    # |  Private Types
    # |
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    private immutable class _Lexer:
        public UIntArch val unique_id
        public String val display_name
        public List<Phrase> val phrases

        public abstract (LexResult | None) val Execute(
            any:
                DynamicPhrase immutable phrase,
                UniqueId immutable unique_id,
                NormalizedIterator var iter,
                Observer ref observer,
            key:
                Bool immutable ignore_whitespace,
        )

    # ----------------------------------------------------------------------
    private immutable class _StandardLexer
        extends _Lexer
    :
        [NoInit, NoCompare, NoSerialize] private OrPhrase val _or_phrase

        # ----------------------------------------------------------------------
        public override (LexResult | None) val Execute(
            any:
                DynamicPhrase immutable phrase,
                UniqueId immutable unique_id,
                NormalizedIterator var iter,
                Observer ref observer,
            key:
                Bool immutable ignore_whitespace,
        ):
            python_hack: LexResult = Phrase.LexResult
            python_hack: NormalizedIteratorRange = Phrase.NormalizedIteratorRange
            python_hack: PhraseLexResultData = Phrase.PhraseLexResultData

            if not self.phrases:
                # TODO: with iter as val:
                # TODO:     return LexResult(False, NormalizedIteratorRange(iter, iter), None)

                # TODO: Remove (begin)
                return LexResult(False, NormalizedIteratorRange(iter.Clone(), iter.Clone()), None)
                # TODO: Remove (end)

            val result = self._or_phrase.Lex(
                unique_id + (self._or_phrase.Name, ),
                move iter,
                # TODO: ref observer,
                observer,
                ignore_whitespace=ignore_whitespace,
            )

            if result is None:
                return None

            return LexResult(
                result.success,
                result.range,
                PhraseLexResultData(phrase, result.data, unique_id),
            )

        # ----------------------------------------------------------------------
        private None __Init?__():
            self._or_phrase = OrPhrase.Create(
                self.phrases,
                name=self.display_name,
            ) as val

    # ----------------------------------------------------------------------
    private immutable class _LeftRecursiveLexer
        extends _Lexer
    :
        # ----------------------------------------------------------------------
        # |
        # |  Data
        # |
        # ----------------------------------------------------------------------
        public List<Phrase>{ min_length'=1 } val left_recursive_phrases

        [NoInit, NoCompare, NoSerialize] private OrPhrase val _prefix_phrase
        [NoInit, NoCompare, NoSerialize] private OrPhrase val _suffix_phrase
        [NoInit, NoCompare, NoSerialize] private OrPhrase val _pseudo_phrase

        # ----------------------------------------------------------------------
        # |
        # |  Public Methods
        # |
        # ----------------------------------------------------------------------
        public override LexResult val Execute(
            any:
                DynamicPhrase immutable phrase,
                UniqueId immutable unique_id,
                NormalizedIterator var iter,
                Observer ref observer,
            key:
                Bool immutable ignore_whitespace,
        ):
            python_hack: LexResult = Phrase.LexResult
            python_hack: NormalizedIteratorRange = Phrase.NormalizedIteratorRange
            python_hack: PhraseLexResultData = Phrase.PhraseLexResultData
            python_hack: TokenLexResultData = Phrase.TokenLexResultData

            # ----------------------------------------------------------------------
            private (Phrase, UniqueId, ) _PhraseIterator():
                yield (
                    self._prefix_phrase,
                    # TODO: unique_id + "__Prefix__",
                    unique_id + ("__Prefix__", ),
                )

                var iteration = 0

                while True:
                    python_hack: iteration_str = str(iteration)

                    yield (
                        self._suffix_phrase,
                        # TODO: unique_id + ("__Suffix__", iteration.ToString(), )
                        unique_id + ("__Suffix__", iteration_str), # TODO
                    )
                    iteration += 1

            # ----------------------------------------------------------------------

            val original_iter = iter.Clone()

            var data_items = List<PhraseLexResultData>()
            var phrase_iterator = _PhraseIterator()

            while True:
                # TODO: val (this_phrase, this_unique_id, ) = next phrase_iterator
                python_hack: this_phrase, this_unique_id = next(phrase_iterator)

                val this_result = this_phrase.Lex(
                    this_unique_id,
                    move iter,
                    # TODO: ref observer,
                    observer,
                    ignore_whitespace=ignore_whitespace,
                )

                if this_result is None:
                    return None

                if not data_items or this_result.success:
                    iter = this_result.range.end.Clone()

                assert this_result.data is not None
                data_items.InsertBack?(this_result.data)

                if not this_result.success:
                    break

            assert data_items

            val error_data_item = data_items.RemoveBack?()
            val range = NormalizedIteratorRange(original_iter, iter) # TODO: iter as val)

            if not data_items:
                return LexResult(
                    False,
                    range,
                    PhraseLexResultData(self, error_data_item, unique_id),
                )

            # Strip the prefix- and suffix-cruft from the output data so that we can simulate
            # results as if they came from a standard phrase.
            for (data_item_index, data_item, ) in Enumerate(data_items):
                assert data_item.phrase is OrPhrase
                assert data_item.data is not None

                data_items[data_item_index] = data_item.data

            # Massage the results into the expected format
            for (data_item_index, data_item, ) in Enumerate(data_items):
                if data_item_index != 0:
                    # The number of non-ignored data items should be 1 less than the number of
                    # non-control-token data items; when we merge this one the phrase will be
                    # complete.

                    # TODO: if __debug__:
                    if True:
                        assert data_item.phrase is SequencePhrase
                        assert data_item.data is PhraseContainerLexResultData

                        val non_ignored_data_items = Sum(
                            1 if not di is TokenLexResultData or not di.is_ignored else 0
                            for di in data_item.data.data_items
                        )

                        val non_control_token_phrases = Sum(
                            1 if not phrase is TokenPhrase or not phrase.token.is_control_token else 0
                            for phrase in data_item.phrase.Phrases
                        )

                        assert non_ignored_data_items == non_control_token_phrases - 1

                    # TODO: data_item.data.data_items.Insert?(0, data_items[data_item_index - 1])
                    python_hack: data_item.data.data_items.insert(0, data_items[data_item_index - 1])

                data_items[data_item_index] = PhraseLexResultData(
                    phrase,
                    PhraseLexResultData(
                        self._pseudo_phrase,
                        data_item,
                        # Don't worry about providing an unique_id here, as they are all going to be
                        # overwritten below.
                        unique_id,
                    ),
                    unique_id,
                )

            val data = data_items[-1]

            # We may need to alter the tree if we are working with a combination of left- and right-
            # recursive phrases.
            var value_data = DynamicPhrase.SkipDynamicData(data)

            if (
                DynamicPhrase.IsLeftRecursivePhrase(value_data.phrase, phrase.phrases_type)
                and DynamicPhrase.IsRightRecursivePhrase(value_data.phrase, phrase.phrases_type)
            ):
                assert value_data.data is PhraseContainerLexResultData
                assert value_data.data.data_items[-1] is PhraseLexResultData

                value_data = DynamicPhrase.SkipDynamicData(value_data.data.data_items[-1])

                if DynamicPhrase.IsRightRecursivePhrase(value_data.phrase, phrase.phrases_type):
                    # TODO: Add tests with a combo of mathematical, logical, and func operators ('.', '->', etc.)
                    #       Not all types should support this decoration, but right now it is applied to all; tests
                    #       will illustrate the problem.
                    #
                    #             one and two.three.Four() -> (((one and two).three).Four())     <<This is not correct>>

                    # Splitting phrases into those that are left-recursive and those that
                    # aren't avoids infinite recursion with left-recursive phrases, but it
                    # means that we are overly greedy for those phrases that are also right-
                    # recursive. So, we have to perform some tree manipulation to end up with
                    # the results that we want. The diagrams below illustrate the scenario and operations.
                    #
                    #   ==============================================================================
                    #
                    #   Scenario                            Should be parsed as:
                    #   ----------------------------------  ------------------------------------------
                    #   1 + 2 - 3                           ((1 + 2) - 3)
                    #
                    #   What we have (incorrect):           What we want (correct):
                    #   ----------------------------------  ------------------------------------------
                    #   root -->     +                      new_root --> -
                    #               / \                                 / \
                    #              1   -   <-- new_root     root -->   +   3
                    #                 / \                             / \
                    #   travel -->   2   3                           1   2  <-- travel
                    #
                    #   ==============================================================================
                    #
                    #   Scenario                            Should be parsed as:
                    #   ----------------------------------  ------------------------------------------
                    #   1 + 2 - 3 * 4                       (((1 + 2) - 3) * 4)
                    #
                    #   What we have (incorrect):           What we want (correct):
                    #   ----------------------------------  ------------------------------------------
                    #   root -->     +                      new_root --> *
                    #               / \                                 / \
                    #              1   *    <-- new_root               -   4
                    #                 / \                             / \
                    #   travel -->   -   4                  root --> +   3
                    #               / \                             / \
                    #              2   3                           1   2  <-- travel
                    #
                    #   ==============================================================================
                    #
                    #   1) Identify travel (left-most left-recursive phrase)
                    #   2) Root last = travel first
                    #   3) Travel first = root
                    #   4) Root = new root

                    var root_dynamic = data
                    var root_actual = DynamicPhrase.SkipDynamicData(root_dynamic)

                    assert root_actual.phrase is SequencePhrase
                    assert root_actual.data is PhraseContainerLexResultData

                    var new_root_dynamic = root_actual.data.data_items[-1]
                    var new_root_actual = DynamicPhrase.SkipDynamicData(new_root_dynamic)

                    assert new_root_actual.phrase is SequencePhrase
                    assert new_root_actual.data is PhraseContainerLexResultData

                    var travel = new_root_actual

                    while True:
                        var potential_travel_dynamic = travel.data.data_items[0]
                        var potential_travel_actual = DynamicPhrase.SkipDynamicData(potential_travel_dynamic)

                        if not DynamicPhrase.IsRightRecursivePhrase(potential_travel_actual.phrase, phrase.phrases_type):
                            break

                        travel = potential_travel_actual

                    root_actual.data.data_items[-1] = travel.data.data_items[0]
                    travel.data.data_items[0] = data

                    data = new_root_dynamic

            assert data is PhraseLexResultData

            if not phrase.is_valid_data_func(data):
                return LexResult(False, range, data)

            # At this point, we have massaged and modified the structure of the tree to the point where
            # attempting to use previously cached values will not work. Update all of the unique_ids for
            # all data in the hierarchy to prevent caching.

            # TODO: val unique_id_suffix_str = "Pseudo ({})".Format(Uuid())
            python_hack: unique_id_suffix_str = "Pseudo ({})".format(uuid.uuid4())
            var unique_id_suffix_iteration = 0

            # ----------------------------------------------------------------------
            private None _UpdateUniqueIds
                |
                    unique_id_suffix_iteration,
                |
                (
                    (LexResultData | None) mutable data,
            ):
            # TODO: ^^^^ shoudl allow ")\n<dedent>:\n"

                if data is None:
                    return

                if data is PhraseLexResultData:
                    # TODO: data.unique_id = UniqueId((unique_id_suffix_str, unique_id_suffix_iteration.ToString(), ))
                    python_hack: data.unique_id = (unique_id_suffix_str, str(unique_id_suffix_iteration))

                    unique_id_suffix_iteration += 1
                    _UpdateUniqueIds(data.data)

                elif data is PhraseContainerLexResultData:
                    for data_item in data.data_items:
                        _UpdateUniqueIds(data_item)

                elif data is TokenLexResultData:
                    # Nothing to do here
                    pass

                else:
                    assert False, data

            # ----------------------------------------------------------------------

            _UpdateUniqueIds(data)

            data = PhraseLexResultData(
                data.phrase,
                data.data,
                data.unique_id,
                error_data_item,
            )

            return LexResult(True, range, data)

        # ----------------------------------------------------------------------
        # |
        # |  Private Types
        # |
        # ----------------------------------------------------------------------
        python_hack: Phrase = Phrase

        [PrivateCtor]
        private immutable class _SequenceSuffixWrapper
            extends Phrase
        :
            private SequencePhrase val _phrase

            # ----------------------------------------------------------------------
            public static _SequenceSuffixWrapper val Create(
                SequencePhrase val phrase,
            ):
                python_hack: _SequenceSuffixWrapper = DynamicPhrase._LeftRecursiveLexer._SequenceSuffixWrapper

                return _SequenceSuffixWrapper(
                    "_SequenceSuffixWrapper",
                    phrase,
                ) as val

            # ----------------------------------------------------------------------
            public override immutable (LexResult | None) val Lex(
                any:
                    UniqueId val unique_id,
                    NormalizedIterator var iter,
                    Observer ref observer,
                key:
                    Bool val ignore_whitespace = False,
            ):
                return self._phrase.LexSuffix(
                    unique_id,
                    move iter,
                    # TODO: ref observer,
                    observer,
                    ignore_whitespace=ignore_whitespace,
                )

        # ----------------------------------------------------------------------
        # |
        # |  Private Methods
        # |
        # ----------------------------------------------------------------------
        private None __Init?__():
            assert self.phrases

            self._prefix_phrase = OrPhrase.Create(
                self.phrases,
                # TODO: name=`{self.display_name} <Prefix>`,
                name="{} <Prefix>".Format(self.display_name),
            ) as val

            python_hack: _SequenceSuffixWrapper = DynamicPhrase._LeftRecursiveLexer._SequenceSuffixWrapper

            python_hack: python_workaround = [_SequenceSuffixWrapper.Create(phrase) for phrase in self.left_recursive_phrases]

            self._suffix_phrase = OrPhrase.Create(
                # TODO: [_SequenceSuffixWrapper.Create(phrase) for phrase in self.left_recursive_phrases]
                python_workaround,
                # TODO: name=`{self.display_name} <Suffix>`,
                name="{} <Suffix>".Format(self.display_name),
            ) as val

            self._pseudo_phrase = OrPhrase.Create(
                self.left_recursive_phrases + self.phrases,
                name=self.display_name,
            ) as val

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # |
    # |  Private Methods
    # |
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    private override mutable Bool val _PopulateRecursiveImpl(Phrase val new_phrase):
        # Nothing downstream has changed because we will get the new set of phrases in the category
        # upon each invocation.
        return False
