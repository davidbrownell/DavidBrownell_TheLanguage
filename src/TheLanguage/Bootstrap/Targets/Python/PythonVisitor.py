import itertools
import os
import textwrap
import uuid

from io import StringIO

from contextlib import contextmanager
from typing import Any, Callable, List, Optional, TextIO, Tuple, Union

import CommonEnvironment
from CommonEnvironment.CallOnExit import CallOnExit
from CommonEnvironment import Interface
from CommonEnvironment.StreamDecorator import StreamDecorator
from CommonEnvironment import StringHelpers

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from ...Parser.Common.VisitorTools import StackHelper
    from ...Parser.Visitor import *


# ----------------------------------------------------------------------
class PythonVisitor(Visitor):
    # ----------------------------------------------------------------------
    def Pass1(
        self,
        common_library_import_prefix: str,
        parser_info: ParserInfo,
        indent_level: Optional[int]=None,
    ) -> str:
        sink = StringIO()

        self._stream_stack: List[TextIO] = [sink]
        self._indentation = " " * (indent_level or 4)
        self._import_statements = []
        self._imports = {}
        self._prev_line: Optional[int] = None
        self._import_prefix = common_library_import_prefix
        self._unique_id_stack = []

        self.Accept(parser_info, [])

        return sink.getvalue()

    # ----------------------------------------------------------------------
    def Pass2(
        self,
        content: str,
    ) -> str:
        if self._import_statements:
            imports = StringHelpers.LeftJustify(
                "\n".join(self._import_statements),
                len(self._indentation),
            )
        else:
            imports = ""

        content = content.replace(self._IMPORTS_PLACEHOLDER, imports)

        lines = content.split("\n")

        for line_index, line in enumerate(lines):
            if line.isspace():
                lines[line_index] = ""

        content = "\n".join(lines)

        return content

    # ----------------------------------------------------------------------
    @Interface.override
    def Accept(
        self,
        parser_info: ParserInfo,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        *args,
        **kwargs,
    ):
        # TODO: This code doesn't work; fix in the future
        if self._prev_line is not None and self._prev_line != parser_info.Regions__.Self__.Begin.Line: # type: ignore && pylint: disable=no-member
            assert parser_info.Regions__.Self__.Begin.Line > self._prev_line  # type: ignore && pylint: disable=no-member

            self._stream.write("\n" * (parser_info.Regions__.Self__.Begin.Line - self._prev_line)) # type: ignore && pylint: disable=no-member

        self._prev_line = parser_info.Regions__.Self__.End.Line # type: ignore && pylint: disable=no-member

        return super(PythonVisitor, self).Accept(parser_info, stack, *args, **kwargs)

    # ----------------------------------------------------------------------
    @Interface.override
    def OnRoot(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: RootParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:

        self._stream.write(
            textwrap.dedent(
                """\
                # ----------------------------------------------------------------------
                # |
                # |  This file has been automatically generated by {name}.
                # |
                # ----------------------------------------------------------------------
                {documentation}

                import copy
                from enum import auto, Enum

                from CommonEnvironmentEx.Package import InitRelativeImports

                with InitRelativeImports():
                    from {import_prefix}CommonLibrary import HashLib_TheLanguage as HashLib
                    from {import_prefix}CommonLibrary.Int_TheLanguage import *
                    from {import_prefix}CommonLibrary.List_TheLanguage import List
                    # from {import_prefix}CommonLibrary.Num_TheLanguage import Num
                    # from {import_prefix}CommonLibrary.Queue_TheLanguage import Queue
                    from {import_prefix}CommonLibrary.Range_TheLanguage import *
                    from {import_prefix}CommonLibrary.Set_TheLanguage import Set
                    from {import_prefix}CommonLibrary.Stack_TheLanguage import Stack
                    from {import_prefix}CommonLibrary.String_TheLanguage import String

                    {imports_placeholder}

                """,
            ).format(
                name=_script_name,
                documentation="" if parser_info.Documentation is None else textwrap.dedent(
                    textwrap.dedent(
                        '''\
                        """\\
                        {}
                        """
                        ''',
                    ).format(parser_info.Documentation),
                ),
                imports_placeholder=self._IMPORTS_PLACEHOLDER,
                import_prefix=self._import_prefix,
            ),
        )

    # ----------------------------------------------------------------------
    @Interface.override
    def OnConstraintArgument(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ConstraintArgumentParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            if parser_info.Keyword is not None:
                self._stream.write("{}=".format(parser_info.Keyword))

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnConstraintParameter(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ConstraintParameterParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Type"]:
                self.Accept(parser_info.Type, helper.stack)

            self._stream.write(" {}".format(parser_info.Name))

            if parser_info.Default is not None:
                with helper["Default"]:
                    self._stream.write("=")
                    self.Accept(parser_info.Default, helper.stack)

            self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnConstraintParameters(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ConstraintParametersParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("# Constraint Parameters:\n")

            if parser_info.Positional is not None:
                with helper["Positional"]:
                    self._stream.write("#   Positional:  ")

                    for parameter in parser_info.Positional:
                        self.Accept(parameter, helper.stack)

                    self._stream.write("\n")

            if parser_info.Any is not None:
                with helper["Any"]:
                    self._stream.write("#   Any:  ")

                    for parameter in parser_info.Any:
                        self.Accept(parameter, helper.stack)

                    self._stream.write("\n")

            if parser_info.Keyword is not None:
                with helper["Keyword"]:
                    self._stream.write("#   Keyword:  ")

                    for parameter in parser_info.Keyword:
                        self.Accept(parameter, helper.stack)

                    self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFunctionArgument(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FunctionArgumentParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.Keyword is not None:
            self._stream.write("{}=".format(parser_info.Keyword))

        with StackHelper(stack)[(parser_info, "Expression")] as helper:
            self.Accept(parser_info.Expression, helper.stack)

        self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFunctionParameterType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FunctionParameterTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert parser_info.IsVariadic is None, "Not supported yet"

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFunctionParameter(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FunctionParameterParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(parser_info.Name)

        if parser_info.Default is not None:
            with StackHelper(stack)[(parser_info, "Default")] as helper:
                self._stream.write("=")
                self.Accept(parser_info.Default, helper.stack)

        self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFunctionParameters(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FunctionParametersParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("(")

        if getattr(parser_info, "_add_self", False):
            self._stream.write("self, ")

        with StackHelper(stack)[parser_info] as helper:
            if parser_info.Positional is not None:
                with helper["Positional"]:
                    for parameter in parser_info.Positional:
                        self.Accept(parameter, helper.stack)

            if parser_info.Any:
                with helper["Any"]:
                    for parameter in parser_info.Any:
                        self.Accept(parameter, helper.stack)

            if parser_info.Keyword:
                with helper["Keyword"]:
                    for parameter in parser_info.Keyword:
                        self.Accept(parameter, helper.stack)

        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTemplateArgument(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TemplateArgumentParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.Keyword is not None:
            self._stream.write("{}=".format(parser_info.Keyword))

        if isinstance(parser_info.TypeOrExpression, str):
            self._stream.write(parser_info.TypeOrExpression)
        else:
            with StackHelper(stack)[(parser_info, "Expression")] as helper:
                self.Accept(parser_info.TypeOrExpression, helper.stack)

        self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTemplateTypeParameter(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TemplateTypeParameterParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert parser_info.IsVariadic is None, "Not supported yet"

        with StackHelper(stack)[parser_info] as helper:
            self._stream.write(parser_info.Name)

            if parser_info.Default is not None:
                with helper["Default"]:
                    self._stream.write("={}".format(parser_info.Default))

            self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTemplateDecoratorParameter(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TemplateDecoratorParameterParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Type"]:
                self.Accept(parser_info.Type, helper.stack)

            self._stream.write(parser_info.Name)

            if parser_info.Default is not None:
                with helper["Default"]:
                    self._stream.write("=")
                    self.Accept(parser_info.Default, helper.stack)

            self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTemplateParameters(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TemplateParametersParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("# Template Parameters:\n")

            if parser_info.Positional is not None:
                with helper["Positional"]:
                    self._stream.write("#   Positional:  ")

                    for parameter in parser_info.Positional:
                        self.Accept(parameter, helper.stack)

                    self._stream.write("\n")

            if parser_info.Any is not None:
                with helper["Any"]:
                    self._stream.write("#   Any:  ")

                    for parameter in parser_info.Any:
                        self.Accept(parameter, helper.stack)

                    self._stream.write("\n")

            if parser_info.Keyword is not None:
                with helper["Keyword"]:
                    self._stream.write("#   Keyword:  ")

                    for parameter in parser_info.Keyword:
                        self.Accept(parameter, helper.stack)

                    self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBinaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BinaryExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            if parser_info.Operator == BinaryExpressionOperatorType.ChainedFunc:
                if (
                    isinstance(parser_info.Left, GenericNameExpressionParserInfo)
                    and isinstance(parser_info.Right, GenericNameExpressionParserInfo)
                ):
                    if (
                        parser_info.Left.Name == "self"
                        and parser_info.Right.Name == "__Fields__"
                    ):
                        self._stream.write("**self.__dict__")
                        return False

                if (
                    isinstance(parser_info.Right, FuncInvocationExpressionParserInfo)
                    and isinstance(parser_info.Right.Expression, GenericNameExpressionParserInfo)
                ):
                    if parser_info.Right.Expression.Name == "Length":
                        self._stream.write("len(")
                        self.Accept(parser_info.Left, helper.stack)
                        self._stream.write(")")

                        return False

            with helper["Left"]:
                left_content = StringIO()

                self._stream_stack.append(left_content)
                with CallOnExit(self._stream_stack.pop):
                    self.Accept(parser_info.Left, helper.stack)

                left_content = left_content.getvalue()

            with helper["Right"]:
                right_content = StringIO()

                self._stream_stack.append(right_content)
                with CallOnExit(self._stream_stack.pop):
                    self.Accept(parser_info.Right, helper.stack)

                right_content = right_content.getvalue()

            surrounding_spaces = True

            if parser_info.Operator == BinaryExpressionOperatorType.LogicalAnd:
                operator = "and"
            elif parser_info.Operator == BinaryExpressionOperatorType.LogicalOr:
                operator = "or"
            elif parser_info.Operator == BinaryExpressionOperatorType.LogicalIn:
                operator = "in"
            elif parser_info.Operator == BinaryExpressionOperatorType.LogicalNotIn:
                operator = "not in"
            elif parser_info.Operator == BinaryExpressionOperatorType.LogicalIs:
                if not (
                    right_content.startswith("not")
                    or right_content in ["None", "True", "False"]
                ):
                    self._stream.write('{}.__class__.__name__ == "{}"'.format(left_content, right_content))
                    return False

                operator = 'is'

            elif parser_info.Operator == BinaryExpressionOperatorType.ChainedFunc:
                operator = "."
                surrounding_spaces = False
            elif parser_info.Operator == BinaryExpressionOperatorType.ChainedFuncReturnSelf:
                operator = "TODO->"
                surrounding_spaces = False
            elif parser_info.Operator == BinaryExpressionOperatorType.StaticAccessor:
                operator = "."
                surrounding_spaces = False
            elif parser_info.Operator == BinaryExpressionOperatorType.Less:
                operator = "<"
            elif parser_info.Operator == BinaryExpressionOperatorType.LessEqual:
                operator = "<="
            elif parser_info.Operator == BinaryExpressionOperatorType.Greater:
                operator = ">"
            elif parser_info.Operator == BinaryExpressionOperatorType.GreaterEqual:
                operator = ">="
            elif parser_info.Operator == BinaryExpressionOperatorType.Equal:
                operator = "=="
            elif parser_info.Operator == BinaryExpressionOperatorType.NotEqual:
                operator = "!="
            elif parser_info.Operator == BinaryExpressionOperatorType.Add:
                operator = "+"
            elif parser_info.Operator == BinaryExpressionOperatorType.Subtract:
                operator = "-"
            elif parser_info.Operator == BinaryExpressionOperatorType.Multiply:
                operator = "*"
            elif parser_info.Operator == BinaryExpressionOperatorType.Power:
                operator = "**"
            elif parser_info.Operator == BinaryExpressionOperatorType.Divide:
                operator = "/"
            elif parser_info.Operator == BinaryExpressionOperatorType.DivideFloor:
                operator = "//"
            elif parser_info.Operator == BinaryExpressionOperatorType.Modulo:
                operator = "%"
            elif parser_info.Operator == BinaryExpressionOperatorType.BitShiftLeft:
                operator = "<<"
            elif parser_info.Operator == BinaryExpressionOperatorType.BitShiftRight:
                operator = ">>"
            elif parser_info.Operator == BinaryExpressionOperatorType.BitXor:
                operator = "^"
            elif parser_info.Operator == BinaryExpressionOperatorType.BitAnd:
                operator = "&"
            elif parser_info.Operator == BinaryExpressionOperatorType.BitOr:
                operator = "|"
            else:
                assert False, parser_info.Operator

            self._stream.write(left_content)

            if surrounding_spaces:
                self._stream.write(" {} ".format(operator))
            else:
                self._stream.write(operator)

            self._stream.write(right_content)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnCastExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: CastExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write(" # as ")

            if isinstance(parser_info.Type, TypeModifier):
                self._stream.write(str(parser_info.Type.name))
            else:
                with helper["Type"]:
                    self.Accept(parser_info.Type, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncInvocationExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncInvocationExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            if isinstance(parser_info.Arguments, bool):
                assert parser_info.Arguments is False
                self._stream.write("()")
            else:
                with helper["Arguments"]:
                    self._stream.write("(")

                    for argument in parser_info.Arguments:
                        self.Accept(argument, helper.stack)

                    self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGeneratorExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: GeneratorExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["ResultExpression"]:
                self.Accept(parser_info.ResultExpression, helper.stack)

            self._stream.write(" for ")

            with helper["Name"]:
                self.Accept(parser_info.Name, helper.stack)

            self._stream.write(" in ")

            with helper["SourceExpression"]:
                self.Accept(parser_info.SourceExpression, helper.stack)

            if parser_info.ConditionExpression is not None:
                self._stream.write(" if ")

                with helper["ConditionExpression"]:
                    self.Accept(parser_info.ConditionExpression, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGenericNameExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: GenericNameExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.Name == "Format":
            self._stream.write("format")
        elif parser_info.Name == "Join":
            self._stream.write("join")
        else:
            self._stream.write(parser_info.Name.replace("?", "_"))

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGroupExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: GroupExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("(")
        self.Accept(parser_info.Expression, stack)
        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIndexExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IndexExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write("[")

            with helper["Index"]:
                self.Accept(parser_info.Index, helper.stack)

            self._stream.write("]")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnLambdaExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: LambdaExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("(lambda")

            if isinstance(parser_info.Parameters, bool):
                assert parser_info.Parameters is False
            else:
                self._stream.write(" ")

                with helper["Parameters"]:
                    sink = StringIO()

                    self._stream_stack.append(sink)
                    with CallOnExit(self._stream_stack.pop):
                        self.Accept(parser_info.Parameters, helper.stack)

                    sink = sink.getvalue()
                    assert sink[0] == '(', sink
                    assert sink[-1] == ')', sink

                    self._stream.write(sink[1:-1])

            self._stream.write(": ")

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchTypeExpressionClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchTypeExpressionClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert False, "TODO: Not implemented yet"

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchTypeExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchTypeExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert False, "TODO: Not implemented yet"

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchValueExpressionClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchValueExpressionClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert False, "TODO: Not implemented yet"

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchValueExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchValueExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert False, "TODO: Not implemented yet"

    # ----------------------------------------------------------------------
    @Interface.override
    def OnSliceExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: SliceExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            if parser_info.StartExpression is not None:
                with helper["StartExpression"]:
                    self.Accept(parser_info.StartExpression, helper.stack)

            self._stream.write(":")

            if parser_info.EndExpression is not None:
                with helper["EndExpression"]:
                    self.Accept(parser_info.EndExpression, helper.stack)

            return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTernaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TernaryExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["TrueExpression"]:
                self.Accept(parser_info.TrueExpression, helper.stack)

            self._stream.write(" if ")

            with helper["ConditionExpression"]:
                self.Accept(parser_info.ConditionExpression, helper.stack)

            self._stream.write(" else ")

            with helper["FalseExpression"]:
                self.Accept(parser_info.FalseExpression, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TupleExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("(")

            with helper["Expressions"]:
                for expression in parser_info.Expressions:
                    self.Accept(expression, helper.stack)
                    self._stream.write(", ")

            self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnUnaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: UnaryExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            prefix = ""
            suffix = ""

            if parser_info.Operator == UnaryExpressionOperatorType.Await:
                prefix = "await "
            elif parser_info.Operator == UnaryExpressionOperatorType.Copy:
                pass
            elif parser_info.Operator == UnaryExpressionOperatorType.Final:
                pass
            elif parser_info.Operator == UnaryExpressionOperatorType.Move:
                pass
            elif parser_info.Operator == UnaryExpressionOperatorType.Not:
                prefix = "not "
            elif parser_info.Operator == UnaryExpressionOperatorType.Positive:
                prefix = "+"
            elif parser_info.Operator == UnaryExpressionOperatorType.Negative:
                prefix = "-"
            elif parser_info.Operator == UnaryExpressionOperatorType.BitCompliment:
                prefix = "~"
            else:
                assert False, parser_info.Operator

            if prefix:
                self._stream.write(prefix)

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            if suffix:
                self._stream.write("suffix")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBoolLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BoolLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(str(parser_info.Value))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnCharacterLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: CharacterLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("'{}'".format(parser_info.Value))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIntLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IntLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(str(parser_info.Value))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoneLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NoneLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("None")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNumberLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NumberLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(str(parser_info.Value))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnStringLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: StringLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write('"{}"'.format(parser_info.Value.replace('"', '\\"')))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleName(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TupleNameParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[(parser_info, "Names")] as helper:
            self._stream.write("(")

            for name in parser_info.Names:
                self.Accept(name, helper.stack)
                self._stream.write(", ")

            self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableName(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariableNameParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(parser_info.Name.replace("self_", "self."))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnAssertStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: AssertStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("assert ")

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            if parser_info.DisplayExpression is not None:
                with helper["DisplayExpression"]:
                    self._stream.write(", ")
                    self.Accept(parser_info.DisplayExpression, helper.stack)

            self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBinaryStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BinaryStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Name"]:
                self.Accept(parser_info.Name, helper.stack)

            if parser_info.Operator == BinaryStatementOperatorType.Assignment:
                operator = "="
            elif parser_info.Operator == BinaryStatementOperatorType.AddInplace:
                operator = "+="
            elif parser_info.Operator == BinaryStatementOperatorType.SubtractInplace:
                operator = "-="
            elif parser_info.Operator == BinaryStatementOperatorType.MultiplyInplace:
                operator = "*="
            elif parser_info.Operator == BinaryStatementOperatorType.PowerInplace:
                operator = "**="
            elif parser_info.Operator == BinaryStatementOperatorType.DivideInplace:
                operator = "/="
            elif parser_info.Operator == BinaryStatementOperatorType.DivideFloorInplace:
                operator = "//="
            elif parser_info.Operator == BinaryStatementOperatorType.ModuloInplace:
                operator = "%="
            elif parser_info.Operator == BinaryStatementOperatorType.BitShiftLeftInplace:
                operator = "<<="
            elif parser_info.Operator == BinaryStatementOperatorType.BitShiftRightInplace:
                operator = ">>="
            elif parser_info.Operator == BinaryStatementOperatorType.BitXorInplace:
                operator = "^="
            elif parser_info.Operator == BinaryStatementOperatorType.BitAndInplace:
                operator = "&="
            elif parser_info.Operator == BinaryStatementOperatorType.BitOrInplace:
                operator = "|="
            else:
                assert False, parser_info.Operator

            self._stream.write(" {} ".format(operator))

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBreakStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BreakStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("break\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassMemberStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ClassMemberStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing to do here
        pass

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassStatementDependency(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ClassStatementDependencyParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing to do here
        pass

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ClassStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            unique_id = str(uuid.uuid4()).replace("-", "")
            self._unique_id_stack.append(unique_id)
            with CallOnExit(self._unique_id_stack.pop):
                self._stream.write(
                    textwrap.dedent(
                        """\
                        # Visibility: {}
                        # ClassModifier: {}
                        # ClassType: {}
                        """,
                    ).format(
                        parser_info.Visibility.name,
                        parser_info.ClassModifier.name,
                        parser_info.ClassType.name,
                    ),
                )

                if parser_info.Templates is not None:
                    with helper["Templates"]:
                        self.Accept(parser_info.Templates, helper.stack)

                if parser_info.Constraints is not None:
                    with helper["Constraints"]:
                        self.Accept(parser_info.Constraints, helper.stack)

                base_class_prefix = []

                for item in stack[:-1]:
                    if isinstance(item, ClassStatementParserInfo):
                        base_class_prefix.append(item.Name)

                base_class_prefix = ".".join(base_class_prefix)
                if base_class_prefix:
                    base_class_prefix += "."

                # ----------------------------------------------------------------------
                def ToTypeName(name):
                    if name in self._imports:
                        return name

                    name = name.replace("::", ".")
                    if name.startswith(base_class_prefix):
                        return name

                    return "{}{}".format(base_class_prefix, name)

                # ----------------------------------------------------------------------

                base_classes = [
                    dependency.Name
                    for dependency in itertools.chain(
                        (parser_info.Extends or []),
                        (parser_info.Implements or []),
                        (parser_info.Uses or []),
                    )
                ]

                generate_init_method = True

                if base_classes:
                    standard_base = None
                elif parser_info.ClassType == ClassType.Exception:
                    standard_base = "Exception"
                elif parser_info.ClassType == ClassType.Enum:
                    standard_base = "Enum"
                    generate_init_method = False
                else:
                    standard_base = "object"

                self._stream.write(
                    "class {}({}):\n".format(
                        parser_info.Name,
                        ", ".join(base_classes + ([standard_base] if standard_base is not None else [])),
                    ),
                )

                # Organize the statements
                methods = []
                members = []

                saw_init = False
                saw_to_string = False

                for statement in parser_info.Statements:
                    if isinstance(statement, ClassMemberStatementParserInfo):
                        members.append(statement)
                    else:
                        if isinstance(statement, FuncDefinitionStatementParserInfo):
                            if (
                                statement.Name == FuncDefinitionStatementOperatorType.Init
                                or statement.Name == FuncDefinitionStatementOperatorType.PostInit
                            ):
                                saw_init = True
                            elif statement.Name == FuncDefinitionStatementOperatorType.ToString:
                                saw_to_string = True

                        methods.append(statement)

                with self._Indent():
                    if parser_info.Documentation is not None:
                        self._stream.write(
                            textwrap.dedent(
                                '''\
                                """\\
                                {}
                                """

                                ''',
                            ).format(parser_info.Documentation),
                        )

                    args = []
                    init_statements = []
                    pre_init_statements = []

                    if members:
                        for member in members:
                            if member.InitializedValue is None:
                                initialized_value = None
                            else:
                                sink = StringIO()

                                self._stream_stack.append(sink)
                                with CallOnExit(self._stream_stack.pop):
                                    self.Accept(member.InitializedValue, helper.stack)

                                initialized_value = sink.getvalue()

                            if member.NoInit:
                                init_statements.append(
                                    textwrap.dedent(
                                        """\
                                        # {name}
                                        self.{name} = {value}
                                        """,
                                    ).format(
                                        name=member.Name,
                                        value=initialized_value,
                                    ),
                                )
                            elif member.IsOverride:
                                pre_init_statements.append('kwargs["{}"] = {}'.format(member.Name, initialized_value))

                            else:
                                if initialized_value:
                                    args.append("{}={}".format(member.Name, initialized_value))
                                else:
                                    args.append(member.Name)

                                init_statements.append(
                                    textwrap.dedent(
                                        """\
                                        # {name}
                                        if "{name}" in kwargs:
                                            self.{name} = kwargs.pop("{name}")
                                        elif args:
                                            self.{name} = args.pop(0)
                                        else:
                                            {default_statement}
                                        """,
                                    ).format(
                                        name=member.Name,
                                        value=initialized_value,
                                        default_statement="self.{} = {}".format(member.Name, initialized_value) if initialized_value else 'raise Exception("{} was not provided")'.format(member.Name),
                                    ),
                                )

                    if not base_classes:
                        base_class_comparison_template = "# No bases"
                    else:
                        base_class_comparison_template = StringHelpers.LeftJustify(
                            "\n".join(
                                [
                                    "if {}.{{op}}(self, other) is False: return False".format(ToTypeName(base_class))
                                    for base_class in base_classes
                                ],
                            ),
                            4,
                        )

                    if generate_init_method:
                        self._stream.write(
                            textwrap.dedent(
                                """\
                                def __init__(self, *args, **kwargs):
                                    {class_name}._InternalInit(self, list(args), kwargs)

                                def _InternalInit(self, args, kwargs):
                                    # {args}

                                    {pre_init_statements}{base_init_statements}

                                    {init_statements}

                                    self._Init_{unique_id}_()

                                def __eq__(self, other):
                                    {base_eq}
                                    if not isinstance(other, self.__class__): return False
                                    return self.__class__.__Compare__(self, other) == 0

                                def __ne__(self, other):
                                    {base_ne}
                                    if not isinstance(other, self.__class__): return True
                                    return self.__class__.__Compare__(self, other) != 0

                                def __lt__(self, other):
                                    {base_lt}
                                    if not isinstance(other, self.__class__): return False
                                    return self.__class__.__Compare__(self, other) < 0

                                def __le__(self, other):
                                    {base_le}
                                    if not isinstance(other, self.__class__): return False
                                    return self.__class__.__Compare__(self, other) <= 0

                                def __gt__(self, other):
                                    {base_gt}
                                    if not isinstance(other, self.__class__): return False
                                    return self.__class__.__Compare__(self, other) > 0

                                def __ge__(self, other):
                                    {base_ge}
                                    if not isinstance(other, self.__class__): return False
                                    return self.__class__.__Compare__(self, other) >= 0

                                @classmethod
                                def __Compare__(cls, a, b):
                                {indent}{base_compare_statements}

                                {indent}{compare_statements}

                                {indent}return 0

                                @classmethod
                                def __CompareItem__(cls, a, b):
                                    if a is None and b is None:
                                        return None

                                    if a is None: return -1
                                    if b is None: return 1

                                    try:
                                        if a < b: return -1
                                        if a > b: return 1
                                    except TypeError:
                                        a = id(a)
                                        b = id(b)

                                        if a < b: return -1
                                        if a > b: return 1

                                    return None

                                """,
                            ).format(
                                class_name=ToTypeName(parser_info.Name),
                                unique_id=self._unique_id_stack[-1],
                                indent=self._indentation,
                                args=", ".join(args),
                                pre_init_statements="" if not pre_init_statements else "{}\n\n    ".format(
                                    StringHelpers.LeftJustify(
                                        "\n".join(pre_init_statements),
                                        4,
                                    ),
                                ),
                                base_init_statements="# No bases" if not base_classes else StringHelpers.LeftJustify(
                                    "\n".join(
                                        [
                                            "{}._InternalInit(self, args, kwargs)".format(ToTypeName(base_class))
                                            for base_class in base_classes
                                        ],
                                    ),
                                    4,
                                ).rstrip(),
                                init_statements="# No members" if not init_statements else StringHelpers.LeftJustify(
                                    "\n".join(init_statements),
                                    4,
                                ).rstrip(),
                                base_compare_statements="# No bases" if not base_classes else StringHelpers.LeftJustify(
                                    "".join(
                                        [
                                            textwrap.dedent(
                                                """\
                                                result = {}.__Compare__(a, b)
                                                if result != 0: return result
                                                """,
                                            ).format(ToTypeName(base_class))
                                            for base_class in base_classes
                                        ],
                                    ),
                                    4,
                                ).rstrip(),
                                compare_statements=StringHelpers.LeftJustify(
                                    "\n".join(
                                        [
                                            textwrap.dedent(
                                                """\
                                                result = cls.__CompareItem__(a.{name}, b.{name})
                                                if result is not None: return result
                                                """,
                                            ).format(
                                                name=member.Name,
                                            )
                                            for member in members
                                        ],
                                    ),
                                    len(self._indentation),
                                ).rstrip(),
                                base_eq=base_class_comparison_template.format(op="__eq__"),
                                base_ne=base_class_comparison_template.format(op="__ne__"),
                                base_lt=base_class_comparison_template.format(op="__lt__"),
                                base_le=base_class_comparison_template.format(op="__le__"),
                                base_gt=base_class_comparison_template.format(op="__gt__"),
                                base_ge=base_class_comparison_template.format(op="__ge__"),
                            ),
                        )

                        if not saw_init:
                            self._stream.write(
                                textwrap.dedent(
                                    """\
                                    def _Init_{}_(self):
                                        pass

                                    """,
                                ).format(self._unique_id_stack[-1]),
                            )

                    with helper["Statements"]:
                        for method in methods:
                            self.Accept(method, helper.stack)

                    if saw_to_string:
                        self._stream.write(
                            textwrap.dedent(
                                """\
                                def __str__(self):
                                    return self._ToString_{}_()
                                """,
                            ).format(self._unique_id_stack[-1]),
                        )

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnContinueStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ContinueStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("continue\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnDeleteStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: DeleteStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("del {}\n".format(parser_info.VariableName))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnExitStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ExitStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        assert False, "BugBug"
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncDefinitionStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncDefinitionStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            if parser_info.Templates is not None:
                with helper["Templates"]:
                    self.Accept(parser_info.Templates, helper.stack)

            with helper["ReturnType"]:
                self._stream.write("# Return Type: ")
                self.Accept(parser_info.ReturnType, helper.stack)
                self._stream.write("\n")

            new_stream = self._stream

            if isinstance(parser_info.Name, str):
                name = parser_info.Name.replace("?", "_").replace("!", "_")
            else:
                if parser_info.Name in FUNC_DEFINITION_COMPILE_TIME_OPERATORS:
                    name = parser_info.Name.name

                    new_stream = StreamDecorator(
                        self._stream,
                        line_prefix="# ",
                        skip_first_line_prefix=False,
                    )
                else:
                    name = self._ToOperatorName(parser_info.Name)

            self._stream_stack.append(new_stream)
            with CallOnExit(self._stream_stack.pop):
                if parser_info.MethodModifier in [MethodModifier.static]:
                    self._stream.write("@staticmethod\n")

                self._stream.write("def {}".format(name))

                if isinstance(parser_info.Parameters, bool):
                    assert parser_info.Parameters is False

                    if parser_info.ClassModifier is not None:
                        self._stream.write("(self)")
                    else:
                        self._stream.write("()")
                else:
                    with helper["Parameters"]:
                        if parser_info.ClassModifier is not None:
                            object.__setattr__(parser_info.Parameters, "_add_self", True)

                        self.Accept(parser_info.Parameters, helper.stack)

                self._stream.write(":\n")
                with self._Indent():
                    if parser_info.Statements is not None:

                            if parser_info.Documentation:
                                self._stream.write(
                                    textwrap.dedent(
                                        '''\
                                        """\\
                                        {}
                                        """

                                        ''',
                                    ).format(parser_info.Documentation),
                                )

                            if parser_info.CapturedVariables is not None:
                                with helper["CapturedVariables"]:
                                    for variable in parser_info.CapturedVariables:
                                        self._stream.write("nonlocal ")
                                        self.Accept(variable, helper.stack)
                                        self._stream.write("\n")

                                self._stream.write("\n")

                            with helper["Statements"]:
                                for statement in parser_info.Statements:
                                    self.Accept(statement, helper.stack)
                    else:
                        self._stream.write('raise Exception("Abstract/Deferred method")\n')

            self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncInvocationStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncInvocationStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self.Accept(parser_info.Expression, stack)
        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIfStatementClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IfStatementClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Condition"]:
                self.Accept(parser_info.Condition, helper.stack)

            self._stream.write(":\n")

            with self._Indent():
                with helper["Statements"]:
                    for statement in parser_info.Statements:
                        self.Accept(statement, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIfStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IfStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Clauses"]:
                for clause_index, clause in enumerate(parser_info.Clauses):
                    self._stream.write("{}if ".format("" if clause_index == 0 else "el"))
                    self.Accept(clause, helper.stack)

            if parser_info.ElseStatements:
                with helper["ElseStatements"]:
                    self._stream.write("else:\n")

                    with self._Indent():
                        for statement in parser_info.ElseStatements:
                            self.Accept(statement, helper.stack)

            self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnImportStatementItem(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ImportStatementItemParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        key = parser_info.Alias or parser_info.Name

        assert key not in self._imports, key
        self._imports[key] = parser_info.Name

    # ----------------------------------------------------------------------
    @Interface.override
    def OnImportStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ImportStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.ImportType == ImportStatementImportType.SourceIsDirectory:
            assert len(parser_info.ImportItems) == 1

            self._import_statements.append(
                "from {source}{dot}{imp}_TheLanguage import {imp}{suffix}".format(
                    source=parser_info.SourceFilename,
                    dot="" if parser_info.SourceFilename.startswith("..") else ".",
                    imp=parser_info.ImportItems[0].Name,
                    suffix="" if parser_info.ImportItems[0].Alias is None else " as {}".format(parser_info.ImportItems[0].Alias),
                ),
            )

        elif parser_info.ImportType == ImportStatementImportType.SourceIsModule:
            self._import_statements.append(
                "from {source} import {imports}".format(
                    source=".".join(["" if not component else "{}_TheLanguage".format(component) for component in parser_info.SourceFilename.split(".")]),
                    imports=", ".join(
                        [
                            "{}{}".format(
                                import_item.Name,
                                " as {}".format(import_item.Alias) if import_item.Alias is not None else "",
                            )
                            for import_item in parser_info.ImportItems
                        ],
                    ),
                ),
            )

        else:
            assert False, parser_info.ImportType

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIterateStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IterateStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("for ")

            with helper["Name"]:
                self.Accept(parser_info.Name, helper.stack)

            self._stream.write(" in ")

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write(":\n")

            with self._Indent():
                with helper["Statements"]:
                    for statement in parser_info.Statements:
                        self.Accept(statement, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoopStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NoopStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("pass\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnPythonHackStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: PythonHackStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(parser_info.Content)
        self._stream.write("\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnRaiseStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: RaiseStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("raise")

        if parser_info.Expression is not None:
            with StackHelper(stack)[parser_info] as helper:
                self._stream.write(" ")
                self.Accept(parser_info.Expression, helper.stack)

        self._stream.write("\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnReturnStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ReturnStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("return")

        if parser_info.Expression is not None:
            with StackHelper(stack)[parser_info] as helper:
                self._stream.write(" ")
                self.Accept(parser_info.Expression, helper.stack)

        self._stream.write("\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnScopedRefStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ScopedRefStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Names"]:
                self._stream.write("# Scoped refs: ")

                for name in parser_info.Names:
                    self.Accept(name, helper.stack)

                self._stream.write("\n")

            with helper["Statements"]:
                for statement in parser_info.Statements:
                    self.Accept(statement, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnScopedStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ScopedStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[self] as helper:
            self._stream.write("# Scoped Statement: Begin\n{} = ".format(parser_info.VariableName))

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write("\n\n")

            with helper["Statements"]:
                for statement in parser_info.Statements:
                    self.Accept(statement, helper.stack)

            self._stream.write("# Scoped Statement: End\n\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTryStatementClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TryStatementClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("except ")

            with helper["Type"]:
                self.Accept(parser_info.Type, helper.stack)

            if parser_info.Name is not None:
                self._stream.write(" as {}".format(parser_info.Name))

            self._stream.write(":\n")

            with self._Indent():
                with helper["Statements"]:
                    for statement in parser_info.Statements:
                        self.Accept(statement, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTryStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TryStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("try:\n")

            with helper["TryStatements"]:
                with self._Indent():
                    for statement in parser_info.TryStatements:
                        self.Accept(statement, helper.stack)

            if parser_info.ExceptClauses:
                with helper["ExceptClauses"]:
                    for clause in parser_info.ExceptClauses:
                        self.Accept(clause, helper.stack)

            if parser_info.DefaultStatements:
                with helper["DefaultStatements"]:
                    self._stream.write("except:\n")
                    with self._Indent():
                        for statement in parser_info.DefaultStatements:
                            self.Accept(statement, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTypeAliasStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TypeAliasStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("# Type alias: {} {}".format(parser_info.Visibility.name, parser_info.Name))

            if parser_info.Templates is not None or parser_info.Constraints is not None:
                self._stream.write("\n")

                with self._Indent():
                    if parser_info.Templates is not None:
                        with helper["Templates"]:
                            self.Accept(parser_info.Templates, helper.stack)

                    if parser_info.Constraints is not None:
                        with helper["Constraints"]:
                            self.Accept(parser_info.Constraints, helper.stack)

                self._stream.write("#   ")

            self._stream.write(" = ")

            with helper["Type"]:
                self.Accept(parser_info.Type, helper.stack)

            if parser_info.Templates is not None or parser_info.Constraints is not None:
                self._stream.write("\n")

            self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableDeclarationStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariableDeclarationStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            with helper["Name"]:
                self.Accept(parser_info.Name, helper.stack)

            self._stream.write(" = ")

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableDeclarationOnceStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariableDeclarationOnceStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Note that this won't be part of the final visitor, as the construct will be converted into
        # a VariableDeclarationStatementParserInfo object (likely assigned to an anonymous function)
        self._stream.write("{} = None\n".format(parser_info.VariableName))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnWhileStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: WhileStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("while ")

            with helper["Expression"]:
                self.Accept(parser_info.Expression, helper.stack)

            self._stream.write(":\n")

            with self._Indent():
                with helper["Statements"]:
                    for statement in parser_info.Statements:
                        self.Accept(statement, helper.stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnYieldStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: YieldStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("yield")

        if parser_info.Expression is not None:
            with StackHelper(stack)[parser_info] as helper:
                if parser_info.IsRecursive is not None:
                    assert parser_info.IsRecursive is True
                    self._stream.write(" from")

                with helper["Expression"]:
                    self._stream.write(" ")
                    self.Accept(parser_info.Expression, helper.stack)

        self._stream.write("\n")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoneType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NoneTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("None")
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnStandardType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: StandardTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write(parser_info.TypeName.replace("::", "."))

            if parser_info.Templates:
                with helper["Templates"]:
                    self._stream.write("<")

                    for argument in parser_info.Templates:
                        self.Accept(argument, helper.stack)

                    self._stream.write(">")

            if parser_info.Constraints:
                with helper["Constraints"]:
                    self._stream.write("{")

                    for constraint in parser_info.Constraints:
                        self.Accept(constraint, helper.stack)

                    self._stream.write("}")

            if parser_info.Modifier is not None:
                self._stream.write(" {}".format(parser_info.Modifier.name))

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTypeOfType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TypeOfTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("TypeOf({})".format(parser_info.VariableName))
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TupleTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("Tuple(")

            with helper["Types"]:
                for type_index, type_ in enumerate(parser_info.Types):
                    self.Accept(type_, helper.stack)

                    if type_index != len(parser_info.Types) - 1:
                        self._stream.write(", ")

            self._stream.write(")")

            if parser_info.Modifier is not None:
                self._stream.write(" {}".format(parser_info.Modifier.name))

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariantType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariantTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        with StackHelper(stack)[parser_info] as helper:
            self._stream.write("<")

            with helper["Types"]:
                for type_index, type_ in enumerate(parser_info.Types):
                    self.Accept(type_, helper.stack)

                    if type_index != len(parser_info.Types) - 1:
                        self._stream.write(" | ")

            self._stream.write(">")

            if parser_info.Modifier is not None:
                self._stream.write(" {}".format(parser_info.Modifier.name))

        return False

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    _IMPORTS_PLACEHOLDER                    = "<<<<imports placeholder>>>>"

    # ----------------------------------------------------------------------
    @property
    def _stream(self):
        return self._stream_stack[-1]

    # ----------------------------------------------------------------------
    @contextmanager
    def _Indent(self):
        self._stream_stack.append(
            StreamDecorator(
                self._stream,
                line_prefix=self._indentation,
                skip_first_line_prefix=False,
            ),  # type: ignore
        )

        with CallOnExit(self._stream_stack.pop):
            yield

    # ----------------------------------------------------------------------
    def _ToOperatorName(
        self,
        operator: FuncDefinitionStatementOperatorType,
    ) -> str:
        has_unique_id = operator in [
            FuncDefinitionStatementOperatorType.Init,
            FuncDefinitionStatementOperatorType.ToString,
        ]

        return "_{}_{}".format(
            operator.name,
            "" if not has_unique_id else "{}_".format(self._unique_id_stack[-1]),
        )
