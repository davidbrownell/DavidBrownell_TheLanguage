# ----------------------------------------------------------------------
# |
# |  PythonVisitor.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-10-18 14:59:28
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Contains the PythonVisitor object"""

import os
import textwrap

from typing import Any, List, Optional, TextIO, Tuple, Union

import CommonEnvironment
from CommonEnvironment.CallOnExit import CallOnExit
from CommonEnvironment import Interface
from CommonEnvironment.StreamDecorator import StreamDecorator

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from ...Parser.Visitor import *


# ----------------------------------------------------------------------
class PythonVisitor(Visitor):
    # ----------------------------------------------------------------------
    def __init__(
        self,
        output_stream: TextIO,
        indent_level: Optional[int]=None,
    ):
        self._stream_stack: List[TextIO]    = [output_stream]
        self._indent_level: int             = indent_level or 2

    # ----------------------------------------------------------------------
    # |
    # |  Root
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnRoot(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: RootParserInfo,
    ) -> Optional[bool]:
        if visit_type == VisitType.Enter:
            self._stream.write(
                textwrap.dedent(
                    """\
                    # ----------------------------------------------------------------------
                    # |
                    # |  This file has been automatically generated by {}.
                    # |
                    # ----------------------------------------------------------------------

                    <<<<imports placeholder>>>

                    """,
                ).format(_script_name),
            )

    # ----------------------------------------------------------------------
    # |
    # |  Common
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnArgument(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ArgumentParserInfo,
    ) -> Optional[bool]:
        if visit_type == VisitType.Enter:
            if parser_info.Keyword is not None:
                self._stream.write(parser_info.Keyword)
                self._stream.write("=")

        elif visit_type == VisitType.Exit:
            self._stream.write(", ")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnParameters(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ParametersParserInfo,
    ) -> Optional[bool]:
        # TODO: Handle 'self' if necessary

        if visit_type == VisitType.Enter:
            self._stream.write("(")
        elif visit_type == VisitType.Exit:
            self._stream.write(")")
        else:
            assert False, visit_type

    # ----------------------------------------------------------------------
    @Interface.override
    def OnParameter(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ParameterParserInfo,
    ) -> Optional[bool]:
        if visit_type == VisitType.Enter:
            self._stream.write(parser_info.Name)

            if parser_info.Default is not None:
                self._stream.write("=")

        elif visit_type == VisitType.Exit:
            self._stream.write(", ")

    # ----------------------------------------------------------------------
    # |
    # |  Expressions
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnBinaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: BinaryExpressionParserInfo,
    ) -> Optional[bool]:
        parser_info.Left.Accept(self, stack)

        if parser_info.Operator == BinaryExpressionOperatorType.LogicalAnd:
            self._stream.write(" and ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalOr:
            self._stream.write(" or ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalIn:
            self._stream.write(" in ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalNotIn:
            self._stream.write(" not in ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalIs:
            self._stream.write(" is ")
        elif parser_info.Operator == BinaryExpressionOperatorType.ChainedFunc:
            assert False, "TODO"
        elif parser_info.Operator == BinaryExpressionOperatorType.ChainedFuncReturnSelf:
            assert False, "TODO"
        elif parser_info.Operator == BinaryExpressionOperatorType.Less:
            self._stream.write(" < ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LessEqual:
            self._stream.write(" <= ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Greater:
            self._stream.write(" > ")
        elif parser_info.Operator == BinaryExpressionOperatorType.GreaterEqual:
            self._stream.write(" >= ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Equal:
            self._stream.write(" == ")
        elif parser_info.Operator == BinaryExpressionOperatorType.NotEqual:
            self._stream.write(" != ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Add:
            self._stream.write(" + ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Subtract:
            self._stream.write(" - ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Multiply:
            self._stream.write(" * ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Power:
            self._stream.write(" ** ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Divide:
            self._stream.write(" / ")
        elif parser_info.Operator == BinaryExpressionOperatorType.DivideFloor:
            self._stream.write(" // ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Modulo:
            self._stream.write(" % ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitShiftLeft:
            self._stream.write(" << ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitShiftRight:
            self._stream.write(" >> ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitXor:
            self._stream.write(" ^ ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitAnd:
            self._stream.write(" && ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitOr:
            self._stream.write(" || ")
        else:
            assert False, parser_info.Operator

        parser_info.Right.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnCastExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: CastExpressionParserInfo,
    ) -> Optional[bool]:
        # Nothing do do here, as python is dynamically typed and doesn't need to case
        pass

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncInvocationExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: FuncInvocationExpressionParserInfo,
    ) -> Optional[bool]:
        parser_info.Expression.Accept(self, stack)

        self._stream.write("(")

        if isinstance(parser_info.Arguments, list):
            for argument in parser_info.Arguments:
                argument.Accept(self, stack)

        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncNameExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: FuncNameExpressionParserInfo,
    ) -> Optional[bool]:
        assert visit_type == VisitType.EnterAndExit
        self._stream.write(parser_info.Name)

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGeneratorExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: GeneratorExpressionParserInfo,
    ) -> Optional[bool]:
        parser_info.ResultExpression.Accept(self, stack)
        self._stream.write(" for ")
        parser_info.Name.Accept(self, stack)
        self._stream.write(" in ")
        parser_info.Name.Accept(self, stack)

        if parser_info.ConditionExpression is not None:
            self._stream.write(" if ")
            parser_info.ConditionExpression.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGroupExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: GroupExpressionParserInfo,
    ) -> Optional[bool]:
        self._stream.write("(")
        parser_info.Expression.Accept(self, stack)
        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIndexExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: IndexExpressionParserInfo,
    ) -> Optional[bool]:
        parser_info.Expression.Accept(self, stack)
        self._stream.write("[")
        parser_info.Index.Accept(self, stack)
        self._stream.write("]")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnLambdaExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: LambdaExpressionParserInfo,
    ) -> Optional[bool]:
        self._stream.write("(lambda ")

        if isinstance(parser_info.Parameters, bool):
            assert parser_info.Parameters is False

            self._stream.write("()")
        else:
            parser_info.Parameters.Accept(self, stack)

        self._stream.write(": ")
        parser_info.Expression.Accept(self, stack)
        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchTypeExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: MatchTypeExpressionParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchTypeExpressionClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: MatchTypeExpressionClauseParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchValueExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: MatchValueExpressionParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchValueExpressionClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: MatchValueExpressionClauseParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTernaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TernaryExpressionParserInfo,
    ) -> Optional[bool]:
        parser_info.TrueExpression.Accept(self, stack)
        self._stream.write(" if ")
        parser_info.ConditionExpression.Accept(self, stack)
        self._stream.write(" else ")
        parser_info.FalseExpression.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TupleExpressionParserInfo,
    ) -> Optional[bool]:
        self._stream.write("(")

        for expression in parser_info.Expressions:
            expression.Accept(self, stack)
            self._stream.write(", ")

        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnUnaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: UnaryExpressionParserInfo,
    ) -> Optional[bool]:
        if parser_info.Operator not in [
            UnaryExpressionOperatorType.Copy,
            UnaryExpressionOperatorType.Move,
        ]:
            if parser_info.Operator == UnaryExpressionOperatorType.Await:
                self._stream.write("await ")
            elif parser_info.Operator == UnaryExpressionOperatorType.Not:
                self._stream.write("not ")
            elif parser_info.Operator == UnaryExpressionOperatorType.Positive:
                self._stream.write("+")
            elif parser_info.Operator == UnaryExpressionOperatorType.Negative:
                self._stream.write("-")
            elif parser_info.Operator == UnaryExpressionOperatorType.BitCompliment:
                self._stream.write("~")
            else:
                assert False, parser_info.Operator

            parser_info.Expression.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: VariableExpressionParserInfo,
    ) -> Optional[bool]:
        # Nothing to do here
        pass

    # ----------------------------------------------------------------------
    # |
    # |  Literals
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnBoolLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: BoolLiteralParserInfo,
    ) -> Optional[bool]:
        self._stream.write(str(parser_info.Value))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIntegerLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: IntegerLiteralParserInfo,
    ) -> Optional[bool]:
        self._stream.write(str(parser_info.Value))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoneLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: NoneLiteralParserInfo,
    ) -> Optional[bool]:
        self._stream.write("None")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNumberLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: NumberLiteralParserInfo,
    ) -> Optional[bool]:
        self._stream.write(str(parser_info.Value))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnStringLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: StringLiteralParserInfo,
    ) -> Optional[bool]:
        self._stream.write('"{}"'.format(parser_info.Value.replace('"', '\\"')))

    # ----------------------------------------------------------------------
    # |
    # |  Names
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleName(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TupleNameParserInfo,
    ) -> Optional[bool]:
        for name in parser_info.Names:
            name.Accept(self, stack)
            self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableName(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: VariableNameParserInfo,
    ) -> Optional[bool]:
        self._stream.write(parser_info.Name)

    # ----------------------------------------------------------------------
    # |
    # |  Statements
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnBinaryStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: BinaryStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBreakStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: BreakStatementParserInfo,
    ) -> Optional[bool]:
        self._stream.write("break\n")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassMemberStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ClassMemberStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ClassStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassStatementDependency(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ClassStatementDependencyParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnContinueStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ContinueStatementParserInfo,
    ) -> Optional[bool]:
        self._stream.write("continue\n")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnDeleteStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: DeleteStatementParserInfo,
    ) -> Optional[bool]:
        self._stream.write("del {}\n".format(parser_info.VariableName))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncDefinitionStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: FuncDefinitionStatementParserInfo,
    ) -> Optional[bool]:
        if parser_info.Statements is not None:
            self._stream.write("def {}".format(parser_info.Name))

            if isinstance(parser_info.Parameters, bool):
                assert parser_info.Parameters is False

                if parser_info.ClassModifier is None or parser_info.MethodModifier == MethodModifier.static:
                    self._stream.write("()")
                else:
                    self._stream.write("(self)")

            else:
                parser_info.Parameters.Accept(self, stack)

            self._stream.write(":\n")

            self._stream_stack.append(
                StreamDecorator(
                    self._stream,
                    line_prefix="  ",
                    skip_first_line_prefix=False,
                ),  # type: ignore
            )

            with CallOnExit(self._stream_stack.pop):
                for statement in parser_info.Statements:
                    statement.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncInvocationStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: FuncInvocationStatementParserInfo,
    ) -> Optional[bool]:
        # Nothing to do here
        pass

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIfStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: IfStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnImportStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ImportStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnImportStatementItem(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ImportStatementItemParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIterateStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: IterateStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoopStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: NoopStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnRaiseStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: RaiseStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnReturnStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ReturnStatementParserInfo,
    ) -> Optional[bool]:
        self._stream.write("return")

        if parser_info.Expression is not None:
            self._stream.write(" ")
            parser_info.Expression.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnScopedRefStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: ScopedRefStatementParserInfo,
    ) -> Optional[bool]:
        # We don't need to do anything here, but don't want children to display
        # themselves.
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTryStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TryStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTryStatementClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TryStatementClauseParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTypeAliasStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TypeAliasStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableDeclarationStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: VariableDeclarationStatementParserInfo,
    ) -> Optional[bool]:
        parser_info.Name.Accept(self, stack)
        self._stream.write(" = ")
        parser_info.Expression.Accept(self, stack)
        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnWhileStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: WhileStatementParserInfo,
    ) -> Optional[bool]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnYieldStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: YieldStatementParserInfo,
    ) -> Optional[bool]:
        self._stream.write("yield")

        if parser_info.IsRecursive is not None:
            self._stream.write(" from")

        if parser_info.Expression is not None:
            parser_info.Expression.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    # |
    # |  Types
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnStandardType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: StandardTypeParserInfo,
    ) -> Optional[bool]:
        # Nothing do do for types
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: TupleTypeParserInfo,
    ) -> Optional[bool]:
        # Nothing do do for types
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariantType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        visit_type: VisitType,
        parser_info: VariantTypeParserInfo,
    ) -> Optional[bool]:
        # Nothing do do for types
        return False

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @property
    def _stream(self):
        return self._stream_stack[-1]
