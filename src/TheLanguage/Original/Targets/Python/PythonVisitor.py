# ----------------------------------------------------------------------
# |
# |  PythonVisitor.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2021-10-18 14:59:28
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2021
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Contains the PythonVisitor object"""

import os
import textwrap

from contextlib import contextmanager
from typing import Any, Callable, List, Optional, TextIO, Tuple, Union

import CommonEnvironment
from CommonEnvironment.CallOnExit import CallOnExit
from CommonEnvironment import Interface
from CommonEnvironment.StreamDecorator import StreamDecorator

from CommonEnvironmentEx.Package import InitRelativeImports

# ----------------------------------------------------------------------
_script_fullpath                            = CommonEnvironment.ThisFullpath()
_script_dir, _script_name                   = os.path.split(_script_fullpath)
# ----------------------------------------------------------------------

with InitRelativeImports():
    from ...Parser.Visitor import *


# ----------------------------------------------------------------------
class PythonVisitor(Visitor):
    # ----------------------------------------------------------------------
    def __init__(
        self,
        output_stream: TextIO,
        indent_level: Optional[int]=None,
    ):
        self._stream_stack: List[TextIO]    = [output_stream]
        self._indentation                   = " " * (indent_level or 2)

    # ----------------------------------------------------------------------
    # |
    # |  Root
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnRoot(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: RootParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(
            textwrap.dedent(
                """\
                # ----------------------------------------------------------------------
                # |
                # |  This file has been automatically generated by {name}.
                # |
                # ----------------------------------------------------------------------
                {documentation}
                <<<<imports placeholder>>>

                """,
            ).format(
                name=_script_name,
                documentation="" if parser_info.Documentation is None else textwrap.dedent(
                    '''\
                    """\\
                    {}
                    """
                    '''.format(parser_info.Documentation.replace('"""', '\\"\\"\\"')),
                ),
            ),
        )

    # ----------------------------------------------------------------------
    # |
    # |  Common
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnArgument(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ArgumentParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.Keyword is not None:
            self._stream.write(parser_info.Keyword)
            self._stream.write("=")

        return lambda: self._stream.write(", ")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnParameters(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ParametersParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # TODO: Handle 'self' if necessary

        self._stream.write("(")
        return lambda: self._stream.write(")")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnParameter(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ParameterParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(parser_info.Name)

        if parser_info.Default is not None:
            self._stream.write("=")

        return lambda: self._stream.write(", ")

    # ----------------------------------------------------------------------
    # |
    # |  Expressions
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnBinaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BinaryExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        parser_info.Left.Accept(self, stack)

        if parser_info.Operator == BinaryExpressionOperatorType.LogicalAnd:
            self._stream.write(" and ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalOr:
            self._stream.write(" or ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalIn:
            self._stream.write(" in ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalNotIn:
            self._stream.write(" not in ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LogicalIs:
            self._stream.write(" is ")
        elif parser_info.Operator == BinaryExpressionOperatorType.ChainedFunc:
            self._stream.write(".")
        elif parser_info.Operator == BinaryExpressionOperatorType.ChainedFuncReturnSelf:
            assert False, "TODO"
        elif parser_info.Operator == BinaryExpressionOperatorType.Less:
            self._stream.write(" < ")
        elif parser_info.Operator == BinaryExpressionOperatorType.LessEqual:
            self._stream.write(" <= ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Greater:
            self._stream.write(" > ")
        elif parser_info.Operator == BinaryExpressionOperatorType.GreaterEqual:
            self._stream.write(" >= ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Equal:
            self._stream.write(" == ")
        elif parser_info.Operator == BinaryExpressionOperatorType.NotEqual:
            self._stream.write(" != ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Add:
            self._stream.write(" + ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Subtract:
            self._stream.write(" - ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Multiply:
            self._stream.write(" * ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Power:
            self._stream.write(" ** ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Divide:
            self._stream.write(" / ")
        elif parser_info.Operator == BinaryExpressionOperatorType.DivideFloor:
            self._stream.write(" // ")
        elif parser_info.Operator == BinaryExpressionOperatorType.Modulo:
            self._stream.write(" % ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitShiftLeft:
            self._stream.write(" << ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitShiftRight:
            self._stream.write(" >> ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitXor:
            self._stream.write(" ^ ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitAnd:
            self._stream.write(" && ")
        elif parser_info.Operator == BinaryExpressionOperatorType.BitOr:
            self._stream.write(" || ")
        else:
            assert False, parser_info.Operator

        parser_info.Right.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnCastExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: CastExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing do do here, as python is dynamically typed and doesn't need to case
        pass

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncInvocationExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncInvocationExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        parser_info.Expression.Accept(self, stack)

        self._stream.write("(")

        if isinstance(parser_info.Arguments, list):
            for argument in parser_info.Arguments:
                argument.Accept(self, stack)

        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncNameExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncNameExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(parser_info.Name)

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGeneratorExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: GeneratorExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        parser_info.ResultExpression.Accept(self, stack)
        self._stream.write(" for ")
        parser_info.Name.Accept(self, stack)
        self._stream.write(" in ")
        parser_info.Name.Accept(self, stack)

        if parser_info.ConditionExpression is not None:
            self._stream.write(" if ")
            parser_info.ConditionExpression.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnGroupExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: GroupExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("(")
        return lambda: self._stream.write(")")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIndexExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IndexExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        parser_info.Expression.Accept(self, stack)
        self._stream.write("[")
        parser_info.Index.Accept(self, stack)
        self._stream.write("]")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnLambdaExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: LambdaExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("(lambda ")

        if isinstance(parser_info.Parameters, bool):
            assert parser_info.Parameters is False

            self._stream.write("()")
        else:
            parser_info.Parameters.Accept(self, stack)

        self._stream.write(": ")
        parser_info.Expression.Accept(self, stack)
        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchTypeExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchTypeExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchTypeExpressionClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchTypeExpressionClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchValueExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchValueExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnMatchValueExpressionClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: MatchValueExpressionClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTernaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TernaryExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        parser_info.TrueExpression.Accept(self, stack)
        self._stream.write(" if ")
        parser_info.ConditionExpression.Accept(self, stack)
        self._stream.write(" else ")
        parser_info.FalseExpression.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TupleExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("(")

        for expression in parser_info.Expressions:
            expression.Accept(self, stack)
            self._stream.write(", ")

        self._stream.write(")")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnUnaryExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: UnaryExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.Operator not in [
            UnaryExpressionOperatorType.Copy,
            UnaryExpressionOperatorType.Move,
        ]:
            if parser_info.Operator == UnaryExpressionOperatorType.Await:
                self._stream.write("await ")
            elif parser_info.Operator == UnaryExpressionOperatorType.Not:
                self._stream.write("not ")
            elif parser_info.Operator == UnaryExpressionOperatorType.Positive:
                self._stream.write("+")
            elif parser_info.Operator == UnaryExpressionOperatorType.Negative:
                self._stream.write("-")
            elif parser_info.Operator == UnaryExpressionOperatorType.BitCompliment:
                self._stream.write("~")
            else:
                assert False, parser_info.Operator

            parser_info.Expression.Accept(self, stack)

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableExpression(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariableExpressionParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing to do here
        pass

    # ----------------------------------------------------------------------
    # |
    # |  Literals
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnBoolLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BoolLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(str(parser_info.Value))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIntegerLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IntegerLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(str(parser_info.Value))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoneLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NoneLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("None")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNumberLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NumberLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(str(parser_info.Value))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnStringLiteral(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: StringLiteralParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write('"{}"'.format(parser_info.Value.replace('"', '\\"')))

    # ----------------------------------------------------------------------
    # |
    # |  Names
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleName(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TupleNameParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        for name in parser_info.Names:
            name.Accept(self, stack)
            self._stream.write(", ")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableName(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariableNameParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(parser_info.Name)

    # ----------------------------------------------------------------------
    # |
    # |  Statements
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnAssertStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: AssertStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("assert ")
        parser_info.Expression.Accept(self, stack)

        if parser_info.DisplayExpression is not None:
            self._stream.write(", ")
            parser_info.DisplayExpression.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBinaryStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BinaryStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnBreakStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: BreakStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("break\n")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassMemberStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ClassMemberStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ClassStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write(
            "class {}({}):\n".format(
                parser_info.Name,
                "object" if parser_info.Base is None else parser_info.Base.Name,
            ),
        )

        with self._Indent():
            class_members = []
            class_methods = []
            has_init_method = False

            for statement in parser_info.Statements:
                if isinstance(statement, ClassMemberStatementParserInfo):
                    class_members.append(statement)
                elif isinstance(statement, FuncDefinitionStatementParserInfo):
                    class_methods.append(statement)

                    if statement.Name == FuncDefinitionStatementOperatorType.Init:
                        assert has_init_method is False
                        has_init_method = True

            if class_members:
                self._stream.write("def __init__(self, {}):\n".format(", ".join([member.Name for member in class_members])))

                with self._Indent():
                    for member in class_members:
                        self._stream.write("self.{member} = {member}\n".format(member=member.Name))

                    self._stream.write("\n")
                    self._stream.write("self.__Init__()\n\n")

                if not has_init_method:
                    self._stream.write(
                        textwrap.dedent(
                            """\
                            def __Init__(self):
                                pass

                            """,
                        ),
                    )

            # Write the methods
            for class_method in class_methods:
                class_method.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnClassStatementDependency(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ClassStatementDependencyParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnContinueStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ContinueStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("continue\n")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnDeleteStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: DeleteStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("del {}\n".format(parser_info.VariableName))

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncDefinitionStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncDefinitionStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        if parser_info.Statements is None:
            self._stream.write("# Abstract/Deferred: ")

        name = parser_info.Name
        if not isinstance(name, str):
            name = "__{}__".format(name.name)

        self._stream.write("def {}".format(name))

        if isinstance(parser_info.Parameters, bool):
            assert parser_info.Parameters is False

            if parser_info.ClassModifier is None or parser_info.MethodModifier == MethodModifier.static:
                self._stream.write("()")
            else:
                self._stream.write("(self)")

        else:
            parser_info.Parameters.Accept(self, stack)

        if parser_info.Statements is not None:
            self._stream.write(":\n")

            with self._Indent():
                for statement in parser_info.Statements:
                    statement.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnFuncInvocationStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: FuncInvocationStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing to do here
        pass

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIfStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IfStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnImportStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ImportStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnImportStatementItem(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ImportStatementItemParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnIterateStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: IterateStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnNoopStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: NoopStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("pass\n")

    # ----------------------------------------------------------------------
    @Interface.override
    def OnRaiseStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: RaiseStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnReturnStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ReturnStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("return")

        if parser_info.Expression is not None:
            self._stream.write(" ")
            parser_info.Expression.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnScopedRefStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: ScopedRefStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # We don't need to do anything here, but don't want children to display
        # themselves.
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTryStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TryStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTryStatementClause(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TryStatementClauseParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTypeAliasStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TypeAliasStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariableDeclarationStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariableDeclarationStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        parser_info.Name.Accept(self, stack)
        self._stream.write(" = ")
        parser_info.Expression.Accept(self, stack)
        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnWhileStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: WhileStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        pass # TODO

    # ----------------------------------------------------------------------
    @Interface.override
    def OnYieldStatement(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: YieldStatementParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        self._stream.write("yield")

        if parser_info.IsRecursive is not None:
            self._stream.write(" from")

        if parser_info.Expression is not None:
            parser_info.Expression.Accept(self, stack)

        self._stream.write("\n")

        return False

    # ----------------------------------------------------------------------
    # |
    # |  Types
    # |
    # ----------------------------------------------------------------------
    @Interface.override
    def OnStandardType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: StandardTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing do do for types
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnTupleType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: TupleTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing do do for types
        return False

    # ----------------------------------------------------------------------
    @Interface.override
    def OnVariantType(
        self,
        stack: List[Union[str, ParserInfo, Tuple[ParserInfo, str]]],
        parser_info: VariantTypeParserInfo,
    ) -> Union[None, bool, Callable[[], Any]]:
        # Nothing do do for types
        return False

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @property
    def _stream(self):
        return self._stream_stack[-1]

    # ----------------------------------------------------------------------
    @contextmanager
    def _Indent(self):
        self._stream_stack.append(
            StreamDecorator(
                self._stream,
                line_prefix=self._indentation,
                skip_first_line_prefix=False,
            ),  # type: ignore
        )

        with CallOnExit(self._stream_stack.pop):
            yield
