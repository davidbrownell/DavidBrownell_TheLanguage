# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String

    from .RecursivePlaceholderPhrase_TheLanguage import RecursivePlaceholderPhrase
    from ..Components_TheLanguage.Phrase_TheLanguage import Phrase, NormalizedIterator

# Visibility: public
# ClassModifier: mutable
# ClassType: Class
class RepeatPhrase(Phrase):
    """\
    Matches content that repeats the provided phrase N times.
    """

    def __init__(self, *args, **kwargs):
        RepeatPhrase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # min_matches, max_matches, _name_is_default, _phrase

        Phrase._InternalInit(self, args, kwargs)

        # min_matches
        if "min_matches" in kwargs:
            self.min_matches = kwargs.pop("min_matches")
        elif args:
            self.min_matches = args.pop(0)
        else:
            raise Exception("min_matches was not provided")

        # max_matches
        if "max_matches" in kwargs:
            self.max_matches = kwargs.pop("max_matches")
        elif args:
            self.max_matches = args.pop(0)
        else:
            raise Exception("max_matches was not provided")

        # _name_is_default
        if "_name_is_default" in kwargs:
            self._name_is_default = kwargs.pop("_name_is_default")
        elif args:
            self._name_is_default = args.pop(0)
        else:
            raise Exception("_name_is_default was not provided")

        # _phrase
        if "_phrase" in kwargs:
            self._phrase = kwargs.pop("_phrase")
        elif args:
            self._phrase = args.pop(0)
        else:
            raise Exception("_phrase was not provided")

        self._Init_124867e2d95447959037e6537e5cca25_()

    def __eq__(self, other):
        compare_cache = {}

        if Phrase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Phrase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Phrase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Phrase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Phrase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Phrase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Phrase.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a.min_matches, b.min_matches, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.max_matches, b.max_matches, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a._name_is_default, b._name_is_default, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a._phrase, b._phrase, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    @property
    def Phrase(self): return self._phrase
    @property
    def MinMatches(self): return self.min_matches
    @property
    def MaxMatches(self): return self.max_matches
    def __hash__(self): return super(RepeatPhrase, self).__hash__()
    # Return Type: RepeatPhrase
    @staticmethod
    def Create(phrase, min_matches, max_matches, name=None, ):
        name_is_default = None
        if name is None:
            name = RepeatPhrase._CreateDefaultName(phrase, min_matches, max_matches, )
            name_is_default = True
        else:
            name_is_default = False

        return RepeatPhrase(name, min_matches, max_matches, name_is_default, phrase, )

    # Return Type: <LexResult | None> val
    def Lex(self, unique_id, iter, observer, ignore_whitespace=False, ):
        LexResult = Phrase.LexResult
        NormalizedIteratorRange = Phrase.NormalizedIteratorRange
        PhraseLexResultData = Phrase.PhraseLexResultData
        PhraseContainerLexResultData = Phrase.PhraseContainerLexResultData
        original_iter = iter.Clone()
        success = False
        observer.StartPhrase(unique_id, self, )
        results = List()
        error_result = None # as <LexResult | None>
        while not iter.AtEnd():
            result = self._phrase.Lex(unique_id + ("{} [{}]".format(self.Name, len(results), ), ), iter.Clone(), observer, ignore_whitespace=ignore_whitespace, )
            if result is None:
                return None

            if not result.success:
                error_result = result
                break

            results.InsertBack_(result.data, )
            iter = result.range.end.Clone()
            if self.max_matches is not None and (len(results) == self.max_matches):
                break

        if len(results) >= self.min_matches:
            success = True
            assert self.max_matches is None or (len(results) <= self.max_matches)
            results = list(results)
            result = LexResult(True, NormalizedIteratorRange(original_iter, iter, ), PhraseLexResultData(self, PhraseContainerLexResultData(results, ), unique_id, error_result.data if error_result is not None else None, ), )
            if observer.OnInternalPhraseProxy(result.data, result.range, ) is None:
                return None

            return result

        if error_result is not None:
            results.InsertBack_(error_result.data, )
            iter = error_result.range.end

        results = list(results)
        return LexResult(False, NormalizedIteratorRange(original_iter, iter, ), PhraseLexResultData(self, PhraseContainerLexResultData(results, ), unique_id, ), )

    # Return Type: None
    def _Init_124867e2d95447959037e6537e5cca25_(self):
        assert self.max_matches is None or self.max_matches >= self.min_matches

    # Return Type: Bool val
    def _PopulateRecursiveImpl(self, new_phrase, ):
        replaced_phrase = False
        if self._phrase.__class__.__name__ == "RecursivePlaceholderPhrase":
            self._phrase = new_phrase
            replaced_phrase = True
        else:
            replaced_phrase = self._phrase.PopulateRecursive(self, new_phrase, ) or replaced_phrase

        if replaced_phrase and self._name_is_default:
            self._name_ = RepeatPhrase._CreateDefaultName(self._phrase, self.min_matches, self.max_matches, )

        return replaced_phrase

    # Return Type: String
    @staticmethod
    def _CreateDefaultName(phrase, min_matches, max_matches, ):
        return "{{{}, {}, {}}}".format(phrase.Name, min_matches, max_matches, )

