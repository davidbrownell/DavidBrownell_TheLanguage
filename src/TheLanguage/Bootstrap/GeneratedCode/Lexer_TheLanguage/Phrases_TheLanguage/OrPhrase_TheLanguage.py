# ----------------------------------------------------------------------
# |
# |  This file has been automatically generated by PythonVisitor.py.
# |
# ----------------------------------------------------------------------


import copy
from enum import auto, Enum

from CommonEnvironmentEx.Package import InitRelativeImports

with InitRelativeImports():
    from ...CommonLibrary import HashLib_TheLanguage as HashLib
    from ...CommonLibrary.Int_TheLanguage import *
    from ...CommonLibrary.List_TheLanguage import List
    # from ...CommonLibrary.Num_TheLanguage import Num
    # from ...CommonLibrary.Queue_TheLanguage import Queue
    from ...CommonLibrary.Range_TheLanguage import *
    from ...CommonLibrary.Set_TheLanguage import Set
    from ...CommonLibrary.Stack_TheLanguage import Stack
    from ...CommonLibrary.String_TheLanguage import String

    from .RecursivePlaceholderPhrase_TheLanguage import RecursivePlaceholderPhrase
    from ..Components_TheLanguage.Phrase_TheLanguage import Phrase

# Visibility: public
# ClassModifier: mutable
# ClassType: Class
class OrPhrase(Phrase):
    """\
    Attempts to match one of the provided phrases.
    """

    def __init__(self, *args, **kwargs):
        OrPhrase._InternalInit(self, list(args), kwargs)

    def _InternalInit(self, args, kwargs):
        # sort_results, ambiguities_resolved_by_order, _name_is_default, _phrases

        Phrase._InternalInit(self, args, kwargs)

        # sort_results
        if "sort_results" in kwargs:
            self.sort_results = kwargs.pop("sort_results")
        elif args:
            self.sort_results = args.pop(0)
        else:
            raise Exception("sort_results was not provided")

        # ambiguities_resolved_by_order
        if "ambiguities_resolved_by_order" in kwargs:
            self.ambiguities_resolved_by_order = kwargs.pop("ambiguities_resolved_by_order")
        elif args:
            self.ambiguities_resolved_by_order = args.pop(0)
        else:
            raise Exception("ambiguities_resolved_by_order was not provided")

        # _name_is_default
        if "_name_is_default" in kwargs:
            self._name_is_default = kwargs.pop("_name_is_default")
        elif args:
            self._name_is_default = args.pop(0)
        else:
            raise Exception("_name_is_default was not provided")

        # _phrases
        if "_phrases" in kwargs:
            self._phrases = kwargs.pop("_phrases")
        elif args:
            self._phrases = args.pop(0)
        else:
            raise Exception("_phrases was not provided")

        self._Init_ce9dc48fa1aa4293ad36a3140e60d3fa_()

    def __eq__(self, other):
        compare_cache = {}

        if Phrase.__eq__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) == 0

    def __ne__(self, other):
        compare_cache = {}

        if Phrase.__ne__(self, other) is False: return False
        if not isinstance(other, self.__class__): return True
        return self.__class__.__Compare__(self, other, compare_cache) != 0

    def __lt__(self, other):
        compare_cache = {}

        if Phrase.__lt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) < 0

    def __le__(self, other):
        compare_cache = {}

        if Phrase.__le__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) <= 0

    def __gt__(self, other):
        compare_cache = {}

        if Phrase.__gt__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) > 0

    def __ge__(self, other):
        compare_cache = {}

        if Phrase.__ge__(self, other) is False: return False
        if not isinstance(other, self.__class__): return False
        return self.__class__.__Compare__(self, other, compare_cache) >= 0

    @classmethod
    def __Compare__(cls, a, b, compare_cache):
        result = Phrase.__Compare__(a, b, compare_cache)
        if result != 0: return result

        result = cls.__CompareItem__(a.sort_results, b.sort_results, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a.ambiguities_resolved_by_order, b.ambiguities_resolved_by_order, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a._name_is_default, b._name_is_default, compare_cache)
        if result is not None: return result

        result = cls.__CompareItem__(a._phrases, b._phrases, compare_cache)
        if result is not None: return result

        return 0

    @classmethod
    def __CompareItem__(cls, a, b, compare_cache):
        cache_key = (id(a), id(b), )

        cache_value = compare_cache.get(cache_key, None)
        if cache_value is not None:
            return cache_value

        def Impl():
            nonlocal a
            nonlocal b

            if a is None and b is None:
                return None

            if a is None: return -1
            if b is None: return 1

            try:
                if a < b: return -1
                if a > b: return 1
            except TypeError:
                a = id(a)
                b = id(b)

                if a < b: return -1
                if a > b: return 1

            return None

        result = Impl()

        compare_cache[cache_key] = result
        return result

    def _Init_ce9dc48fa1aa4293ad36a3140e60d3fa_(self):
        pass

    # Type alias: public Phrases = List<Phrase, >{min_length'=1, }
    @property
    def Phrases(self): return self._phrases
    def __hash__(self): return super(OrPhrase, self).__hash__()
    # Return Type: OrPhrase
    @staticmethod
    def Create(phrases, sort_results=True, ambiguities_resolved_by_order=False, name=None, ):
        name_is_default = None
        if name is None:
            name = OrPhrase._CreateDefaultName(phrases, )
            name_is_default = True
        else:
            name_is_default = False

        return OrPhrase(name, sort_results, ambiguities_resolved_by_order, name_is_default, phrases, )

    # Return Type: <LexResult | None> val
    def Lex(self, unique_id, iter, observer, ignore_whitespace=False, ):
        LexResult = Phrase.LexResult
        NormalizedIteratorRange = Phrase.NormalizedIteratorRange
        PhraseLexResultData = Phrase.PhraseLexResultData
        PhraseContainerLexResultData = Phrase.PhraseContainerLexResultData
        best_result = None # as <LexResult | None>
        observer.StartPhrase(unique_id, self, )
        results = List()
        results.Reserve_(len(self._phrases), )
        for (phrase_index, phrase, ) in Enumerate(self._phrases, ):
            result = phrase.Lex(unique_id + ("{} ({})".format(self.Name, phrase_index, ), ), iter.Clone(), observer, ignore_whitespace=ignore_whitespace, )
            results.InsertBack_(result, )
        best_index = None
        if self.sort_results:
            sort_data = List()
            sort_data.Reserve_(len(self._phrases), )
            for (result_index, result, ) in Enumerate(results, ):
                sort_data.InsertBack_((result.range.end.OffsetProper(), result.success, -result_index, ), )
            sort_data.Sort()
            best_index = -sort_data[-1][-1]
        else:
            for (index, result, ) in Enumerate(results, ):
                if result.success:
                    best_index = index
                    break

            if best_index is None:
                best_index = 0


        best_result = results[best_index]
        range = NormalizedIteratorRange(iter, best_result.range.end, )
        if best_result.success:
            result = LexResult(True, range, PhraseLexResultData(self, best_result.data, unique_id, ), )
            if not observer.OnInternalPhraseProxy(result.data, result.range, ):
                return None

            return result

        all_results = [result.data for result in results]
        return LexResult(False, range, PhraseLexResultData(self, all_results, unique_id, ), )

    # Return Type: Bool val
    def _PopulateRecursiveImpl(self, new_phrase, ):
        replaced_phrase = False
        for (phrase_index, phrase, ) in Enumerate(self._phrases, ):
            if phrase.__class__.__name__ == "RecursivePlaceholderPhrase":
                self._phrases[phrase_index] = new_phrase
                replaced_phrase = True
            else:
                replaced_phrase = phrase.PopulateRecursive(self, new_phrase, ) or replaced_phrase

        if replaced_phrase and self._name_is_default:
            self._name_ = OrPhrase._CreateDefaultName(self._phrases, )

        return replaced_phrase

    # Return Type: String
    @staticmethod
    def _CreateDefaultName(phrases, ):
        return "({})".format(" | ".join(phrase.Name for phrase in phrases, ), )

